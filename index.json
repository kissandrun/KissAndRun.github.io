[{"categories":["折腾指南"],"content":"校园网非常坑，时不时就断了，但校园网也非常的良心，因为他连接校内IP不要钱，不要钱，不要钱，还是上下对等千兆！设备连上了的校园网就会得到一个校内IPv4地址和全球IPv6地址，这俩都是好东西。 ","date":"2021-05-07","objectID":"/network-1/:0:0","tags":["校园网"],"title":"如何充分利用校园网","uri":"/network-1/"},{"categories":["折腾指南"],"content":"校内IP 可以在 设置/网络和Internet/属性 里面查看当前网络的地址。校内IPv4 一般长的是 10.*.*.* 这个样子，IPv6地址一般长的像 2001:*:*:*:*:*的很长一串。但下面这个，就没有拿到校内IP，明显是因为这个设备是路由器下的一个子设备，拿到的地址是192.168.*.*这样的地址。这样的设备是不能作为服务端的，除非在路由器内进行端口绑定，给每一个设备绑定一个端口。但是是可以作为客户端的。 ","date":"2021-05-07","objectID":"/network-1/:1:0","tags":["校园网"],"title":"如何充分利用校园网","uri":"/network-1/"},{"categories":["折腾指南"],"content":"校园网内传输文件 还在使用传统的U盘传文件？还在用垃圾百度网盘传文件？千兆校园网免费传文件为啥不用呢！ 传文件的话总是两个设备直接传文件，我们可以通过一些网络协议进行文件的传输，比如FTP,SFTP,WebDav等等。传文件的逻辑是这样的，一个设备为服务端，进行文件的存储，然后多个设备为客户端，可以通过传输协议从服务端读或写文件，显然我们平时的生活中客户端一般都是Windows系统的电脑，使用Linux系统的用户也不会来看这篇科普文章了。 ","date":"2021-05-07","objectID":"/network-1/:2:0","tags":["校园网"],"title":"如何充分利用校园网","uri":"/network-1/"},{"categories":["折腾指南"],"content":"客户端软件 RaiDrive RaiDrive 是一款将网络位置（比如服务器）映射为本地磁盘的工具。同时也支持支持 Google Drive、Google Photos、Dropbox、OneDrive、FTP、SFTP、WebDAV。 以 Linux 为服务端 以 Linux 为服务端，就很方便，因为使用自带的SFTP协议就可以了，不用安装额外的应用，可以说服务端无需配置。 SFTP 能够直接利用SSH协议映射硬盘，不需要在服务器上做额外的操作。 如上图，添加一个SFTP地址，填入SSH协议的IP地址和端口号，使用密码登录或者Key登录即可。完成后即可在我的计算机里面找到添加的网络位置。可以像操作本地磁盘一样操作服务器上的磁盘了。 以 Windows 为服务端 Windows 虽然有自带的共享功能，但我不会用，整不明白 Windows 的用户权限。推荐使用 FileZilla Server软件，创建一个 FTP 服务端。参考 FTPZilla Server简单配置FTP服务器 ","date":"2021-05-07","objectID":"/network-1/:2:1","tags":["校园网"],"title":"如何充分利用校园网","uri":"/network-1/"},{"categories":["折腾指南"],"content":"远程桌面 还在使用TeamViewer？在校园网环境下，可以使用Windows自带的远程桌面。 要求是被控设备需要是 Windows 10 专业版或者教育版，同时拥有校内IP。如下图，允许通过远程连接此电脑。 客户端则没有版本要求。打开Windows自带的远程桌面 在计算机栏输入 被控设备的 IP ","date":"2021-05-07","objectID":"/network-1/:3:0","tags":["校园网"],"title":"如何充分利用校园网","uri":"/network-1/"},{"categories":["折腾指南"],"content":"充分使用 IPv6 首先测试自己是否拥有 IPv6，进入网站IPv6 测试 (test-ipv6.com) 如果拥有IPv6的话，就可以使用 IPv6了，目前最大的用途就是玩PT，可以访问 蒲公英Pt https://npupt.com 进行探索。 ","date":"2021-05-07","objectID":"/network-1/:4:0","tags":["校园网"],"title":"如何充分利用校园网","uri":"/network-1/"},{"categories":["学习笔记"],"content":"最简 nnUNet 训练 ","date":"2021-04-19","objectID":"/nnunet-2/:0:0","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["学习笔记"],"content":"准备数据 ","date":"2021-04-19","objectID":"/nnunet-2/:1:0","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["学习笔记"],"content":"获得数据 已经将大家分割的图像进行了格式整理和一些预处理，并将其存放在如下目录下volume和label分别是原图和大家手动分割好的标签图 ","date":"2021-04-19","objectID":"/nnunet-2/:1:1","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["学习笔记"],"content":"创建分割任务文件夹 然后在nnUNet_raw_data下新建文件夹 TaskXXX_任务名。 XXX是任务序号(大于100的数，前100被占用了，不如大家就取100 + 自己组的id，比如第21组就取名Task121_任务名)，任务名取一个好记的英文名。 最后的文件结构如下 nnUNet_raw/nnUNet_raw_data/ ├── Task101_BrainTumour ├── Task102_Heart ├── Task103_Liver ├── Task104_Hippocampus ├── Task105_Prostate ├── ... 然后在任务文件夹里构建如下结构 Task101_BrainTumour/ ├── dataset.json ├── imagesTr ├── (imagesTs) └── labelsTr imagesTr 和 labelsTr 分别存放训练的原图和标签。imagesTs存放测试的原图（可以没有）。dataset.json 下面会说。旁边的Task133_LungAirway是一个范例，可以在根据这个进行学习和修改。 ","date":"2021-04-19","objectID":"/nnunet-2/:1:2","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["学习笔记"],"content":"图像命名（可能是整个过程最难的环节） imagesTr 和 labelsTr 中图像的命名也有要求。 其中imagesTr（也就是原图）需要改成类似下图这样，而且必须是 .nii.gz 格式。建议写个 Python 脚本批量重命名并保存成 .nii.gz 格式（如果数量少，也可以手动修改）。 labelsTr（也就是标签图）需要改成如下样式，注意原图和标签图序号一一对应，只是原图后面带**_0000**，而标签图不带。 ","date":"2021-04-19","objectID":"/nnunet-2/:1:3","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["学习笔记"],"content":"dataset.json 编写 上文说到这个任务文件夹应该包含一个 dataset.json 文件。下面是一个例子（可以在Task133里找到） { \"description\": \"Task128_LungLobe\", \"labels\": { \"0\": \"0\", \"1\": \"1\" }, \"licence\": \"see challenge website\", \"modality\": { \"0\": \"CT\" }, \"name\": \"Task128_LungLobe\", \"numTest\": 0, \"numTraining\": 7, \"reference\": \"see challenge website\", \"release\": \"0.0\", \"tensorImageSize\": \"4D\", \"test\": [], \"training\": [ { \"image\": \"./imagesTr/LungLobe_000.nii.gz\", \"label\": \"./labelsTr/LungLobe_000.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_001.nii.gz\", \"label\": \"./labelsTr/LungLobe_001.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_002.nii.gz\", \"label\": \"./labelsTr/LungLobe_002.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_003.nii.gz\", \"label\": \"./labelsTr/LungLobe_003.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_004.nii.gz\", \"label\": \"./labelsTr/LungLobe_004.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_005.nii.gz\", \"label\": \"./labelsTr/LungLobe_005.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_006.nii.gz\", \"label\": \"./labelsTr/LungLobe_006.nii.gz\" } ] } 按自己的任务的属性，修改上面的labels，numTest，numTraining等等信息。注意：这里image的文件名里没有 _0000 。但是修改这个json文件夹的工作量是比较大的，推荐写个 Python 脚本自动生成（当然如果只有几张图，手动改一改也是可以的）。下面是例子 from collections import OrderedDict from batchgenerators.utilities.file_and_folder_operations import save_json def main(): foldername = \"Task128_LungLobe\" #训练的名称 numTraining = 80 #训练集数量 numTest = 6 #测试集数量 numClass = 6 #分割的类别，如果不是多器官分割 则为2 json_dict = OrderedDict() json_dict['name'] = foldername json_dict['description'] = foldername json_dict['tensorImageSize'] = \"4D\" json_dict['reference'] = \"see challenge website\" json_dict['licence'] = \"see challenge website\" json_dict['release'] = \"0.0\" json_dict['modality'] = { \"0\": \"CT\", #模态 } json_dict['labels'] = {i: str(i) for i in range(numClass)} json_dict['numTraining'] = numTraining json_dict['numTest'] = numTest json_dict['training'] = [{'image': \"./imagesTr/LungLobe_{:0\u003e3d}.nii.gz\".format(i), \"label\": \"./labelsTr/LungLobe_{:0\u003e3d}.nii.gz\".format(i)} for i in range(numTraining)] json_dict['test'] = [\"./imagesTs/LungLobe_{:0\u003e3d}.nii.gz\".format(i) for i in range(numTraining, numTraining+numTest)] #上面的LungLobe可以换成自己的任务名 save_json(json_dict, \"./dataset.json\") if __name__ == \"__main__\": main() 需要发挥一点主观能动性，修改一下使之适应自己的任务。运行该脚本需要终端将目录切换到任务文件夹下，然后运行脚本。在终端输入以下命令 ","date":"2021-04-19","objectID":"/nnunet-2/:1:4","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["学习笔记"],"content":"结果 ","date":"2021-04-19","objectID":"/nnunet-2/:1:5","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["学习笔记"],"content":"训练 整理完数据，打开终端，并激活 nnUNet 环境，运行下面命令， nnUNet_plan_and_preprocess -t XXX --verify_dataset_integrity XXX 代替为你的任务序号。该命令进行预处理。(需要一定时间，耐心等待) 开始训练。 单卡训练：执行 nnUNet_train 3d_fullres nnUNetTrainerV2 XXX 0 意思是对序号为XXX的任务进行第0折交叉验证，训练模式是3d的全像素。一共有五折交叉验证，所以最后一个数为0-4。 ","date":"2021-04-19","objectID":"/nnunet-2/:2:0","tags":["Python"],"title":"最简nnUNet训练-医学影像处理入门课程","uri":"/nnunet-2/"},{"categories":["折腾指南"],"content":"Windows下不仅仅有 360全家桶，腾讯全家桶等毒瘤软件，也有很多优秀的效率工具。本文将介绍一些能够大大提升开发效率。 ","date":"2021-03-31","objectID":"/app-1/:0:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐(2)","uri":"/app-1/"},{"categories":["折腾指南"],"content":"RaiDrive 硬盘映射工具 RaiDrive 是一款将网络位置（比如服务器）映射为本地磁盘的工具。同时也支持支持 Google Drive、Google Photos、Dropbox、OneDrive、FTP、SFTP、WebDAV。其中 SFTP 能够直接利用SSH协议映射硬盘，不需要在服务器上做额外的操作。 如上图，添加一个SFTP地址，填入SSH协议的ip地址和端口号，使用密码登录或者Key登录即可。完成后即可在我的计算机里面找到添加的网络位置。可以像操作本地磁盘一样操作服务器上的磁盘了。 ","date":"2021-03-31","objectID":"/app-1/:1:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐(2)","uri":"/app-1/"},{"categories":["折腾指南"],"content":"Tmux 终端复用工具 Tmux是一个终端复用的命令行工具。所谓的终端复用就是在一个终端里面使用多个终端。不仅如此，它还可以让你的程序始终处于运行状态，不管终端是否关闭，只要你的 Tmux 进程没有停止。这就对深度学习训练特别有用。 试想这样一个情形，你用 Pycharm 写了代码，并上传到了服务器，利用 Pycharm 的终端开始了训练，这时你不小心把 Pycharm 关了，或者突然断电了，或者 Win10 又蓝屏又重启更新了，那你的训练就强制停止了。 而如果你是在 Tmux 里的训练的，那没有任何问题，你只要重新 attach 回之前的那个 session 就行。 ","date":"2021-03-31","objectID":"/app-1/:2:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐(2)","uri":"/app-1/"},{"categories":["折腾指南"],"content":"安装 Tmux 首先先确认一下是否安装 Tmux，直接在终端输入tmux如果提醒命令没找到就使用sudo apt install tmux安装 tmux。然后再在终端输入tmux就可以建立一个新的会话。详细的tmux教程可以看 Tmux 使用教程 分离会话（暂时退出该tmux会话） 在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。 $ tmux detach 上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。tmux ls命令可以查看当前所有的 Tmux 会话。 $ tmux ls or $ tmux list-session 接入会话（重新回到tmux会话） tmux attach命令用于重新接入某个已存在的会话。 使用会话编号 $ tmux attach -t 0 使用会话名称 $ tmux attach -t ","date":"2021-03-31","objectID":"/app-1/:2:1","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐(2)","uri":"/app-1/"},{"categories":["折腾指南"],"content":"其他优秀的效率工具 👨‍💻Windows 下优秀软件推荐 - No Visitor Website (kissandrun.github.io) 这里面推荐了一些，比如Autohotkey，utools，Everything，Windows Subsystem for Linux(WSL) 装机用所有软件合集 | Yang’s blog (yangt.me) 这里面也有一些优秀的软件。 ","date":"2021-03-31","objectID":"/app-1/:3:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐(2)","uri":"/app-1/"},{"categories":["折腾指南"],"content":"作为一个炼丹术士，操作服务器是家常便饭，如何高效的操作服务器，管理环境，运行代码便成了头等大事。炼的好不好先不说，得先炼得舒服。 常用的方法无非以下几种： 利用远程桌面（teamviewer，VNC 等工具）全程 GUI 操作 利用本地端的 IDE（如 Pycharm）或者代码编辑器（如 VS Code 等）写代码，然后利用他们的 Remote Tools 进行代码上传等 SSH 到远程服务器，全程 CLI 操作 本文将详细介绍这三种开发的方式 ","date":"2021-03-26","objectID":"/remote-ssh/:0:0","tags":["Vim","Tmux"],"title":"如何用远程服务器进行开发？","uri":"/remote-ssh/"},{"categories":["折腾指南"],"content":"SSH (Secure Shell) 如果你操作远程服务器，那你一定接触过 SSH，如果没有那一定是没到家。SSH是最为基础的连接远程服务器的方法。windows的powershell和几乎所有的Linux发行版都自带SSH，可以在终端中使用。 常用的命令是 ssh user@domain.com 比如 ssh hth@10.9.xx.xx 如果有端口限制则需要加入 -p 参数 ssh -p 端口号 user@domain.com Windows下也可以使用PuTTY等工具使用SSH。这里不得不再推荐一下Windows Subsystem for Linux因为服务器是Linux系统，统一一下环境岂不美哉。 连接上之后就是一个小黑框，里面就可以输入命令行了，可以使用命令行工具比如Tmux和Vim进行开发了，不过单纯的使用CLI比较的难，可以采用Visual Studio Code 进行开发。 ","date":"2021-03-26","objectID":"/remote-ssh/:1:0","tags":["Vim","Tmux"],"title":"如何用远程服务器进行开发？","uri":"/remote-ssh/"},{"categories":["折腾指南"],"content":"Visual Studio Code VSCode 是一个全平台通用的文本编辑器，在官网下载安装即可。 ","date":"2021-03-26","objectID":"/remote-ssh/:2:0","tags":["Vim","Tmux"],"title":"如何用远程服务器进行开发？","uri":"/remote-ssh/"},{"categories":["折腾指南"],"content":"Remote-SSH / 远程开发 安装方法如下所示： 可以让通过SSH连接远程服务器作为本地的开发环境，连接远程服务器最好使用 SSH key，不建议使用密码，否则会不停地在输入密码。 如上图所示，装完最左边的导航栏中就有了远程管理的图标，在里面可以管理你的所有SSH目标，此时新建终端出现的也是远程的终端，此时安装插件也将装在远程服务器上。 ","date":"2021-03-26","objectID":"/remote-ssh/:2:1","tags":["Vim","Tmux"],"title":"如何用远程服务器进行开发？","uri":"/remote-ssh/"},{"categories":["折腾指南"],"content":"Python插件 安装方法和上面相似 VSCode 的 Python 扩展，使 VSCode 拥有调用 Python 解释器的功能。安装成功之后可以新建一个 .py 文件，然后在窗口的左下角选择 Python 解释器，VSCode 会自动搜索系统中的 Python 环境。然后可以 print('hello world') 检查一下是否有问题。 当然细节还有很多，比如代码的美化（Format），错误提示（Lint），代码补全（Completion）等等，这些熟悉了基本操作之后再了解也不迟。 ","date":"2021-03-26","objectID":"/remote-ssh/:2:2","tags":["Vim","Tmux"],"title":"如何用远程服务器进行开发？","uri":"/remote-ssh/"},{"categories":["折腾指南"],"content":"Python远程调试 点击如上框出的按钮,选择调试打开的文件。 调试前可以在行号前打上断点，然后在进行上面的调试，左侧能查看变量，上方的悬浮框可以进行单步调试。 ","date":"2021-03-26","objectID":"/remote-ssh/:2:3","tags":["Vim","Tmux"],"title":"如何用远程服务器进行开发？","uri":"/remote-ssh/"},{"categories":["学习笔记"],"content":"确定最好的 UNet 配置 当模型训练完成之后，使用下面的链接自动选择合适的 UNet 配置。 nnUNet_find_best_configuration -m 2d 3d_fullres 3d_lowres 3d_cascade_fullres -t XXX --strict 注意：五折交叉验证需要全部训练完成。同理 XXX 代表你的任务序号，–strict 参数代表即使配置不存在仍继续执行。 ","date":"2021-03-17","objectID":"/nnunet-1/:1:0","tags":["Python"],"title":"nnUNet 使用不完全指南（下）","uri":"/nnunet-1/"},{"categories":["学习笔记"],"content":"进行标签图的预测 nnUNet_find_best_configuration 会打印出你所需要的命令。当然你也可以手动选择 UNet 配置进行标签图的预测。命令如下： nnUNet_predict -i INPUT_FOLDER -o OUTPUT_FOLDER -t TASK_NAME_OR_ID -m CONFIGURATION --save_npz 注意： 这里的 INPUT_FOLDER 也需要之前的文件结构和文件命名（如果之前已经设置好了，就不必修改了）。-o 代表输出目录， -m 代表所使用的 UNet 配置。 nnUNet 预测所使用的时间较长，需要耐心等待。 ","date":"2021-03-17","objectID":"/nnunet-1/:2:0","tags":["Python"],"title":"nnUNet 使用不完全指南（下）","uri":"/nnunet-1/"},{"categories":["学习笔记"],"content":"其他的一下细节 ","date":"2021-03-17","objectID":"/nnunet-1/:3:0","tags":["Python"],"title":"nnUNet 使用不完全指南（下）","uri":"/nnunet-1/"},{"categories":["学习笔记"],"content":"两阶段的 nnUNet 训练 首先要完成 3d_lowres 的五折交叉验证。也就是分别运行下面的命令： nnUNet_train 3d_lowres nnUNetTrainerV2 TaskXXX_MYTASK 0 --npz nnUNet_train 3d_lowres nnUNetTrainerV2 TaskXXX_MYTASK 1 --npz nnUNet_train 3d_lowres nnUNetTrainerV2 TaskXXX_MYTASK 2 --npz nnUNet_train 3d_lowres nnUNetTrainerV2 TaskXXX_MYTASK 3 --npz nnUNet_train 3d_lowres nnUNetTrainerV2 TaskXXX_MYTASK 4 --npz 然后再进行两阶段的训练。 nnUNet_train 3d_cascade_fullres nnUNetTrainerV2CascadeFullRes TaskXXX_MYTASK FOLD --npz ","date":"2021-03-17","objectID":"/nnunet-1/:3:1","tags":["Python"],"title":"nnUNet 使用不完全指南（下）","uri":"/nnunet-1/"},{"categories":["学习笔记"],"content":"继续训练 如果训练的一半意外停止了可以在原命令后添加 -c 参数继续训练。 ","date":"2021-03-17","objectID":"/nnunet-1/:3:2","tags":["Python"],"title":"nnUNet 使用不完全指南（下）","uri":"/nnunet-1/"},{"categories":["学习笔记"],"content":"多模态图像的训练 上面的例子说的都是单模态的 CT 图的训练，如果是多模态的图像（比如核磁图像），该怎么办呢？其实构建数据时，_0000 标签代表的就是第一个模态，如果是多模态，只需要继续添加 _0001 _0002 标签即可。（不要忘记修改dataset.json文件) ","date":"2021-03-17","objectID":"/nnunet-1/:3:3","tags":["Python"],"title":"nnUNet 使用不完全指南（下）","uri":"/nnunet-1/"},{"categories":["学习笔记"],"content":"使用预训练的 nnUNet 模型 实际上， nnUNet 本身预训练完了一些模型供我们下载，所以它占用了任务号的前100。使用预训练的模型进行预测的方法比较简单，可以看这篇文章。 ","date":"2021-03-17","objectID":"/nnunet-1/:3:4","tags":["Python"],"title":"nnUNet 使用不完全指南（下）","uri":"/nnunet-1/"},{"categories":["学习笔记"],"content":"nnUNet 使用教程 nnUNet 是一个专门用于医学图像的深度学习程序。使用 nnUNet 可以很方便的进行网络的训练和预测。他的集成度很高，能自动的进行合适的预处理，自动的选择合适的网络。 nnUNet 的官方 github 地址是https://github.com/MIC-DKFZ/nnUNet。在 github 里面有英文版的详细教程。网上也有一个不错的教程，地址是https://blog.csdn.net/weixin_42061636/article/details/107623757。这两篇再加本教程可以交叉看，如有出入，github 上的肯定是权威。本文在kissandrun.github.io持续更新。 ","date":"2021-03-14","objectID":"/nnunet-0/:0:0","tags":["Python"],"title":"nnUNet 使用不完全指南（上）","uri":"/nnunet-0/"},{"categories":["学习笔记"],"content":"安装 首先是安装部分。默认读者使用Linux环境，nnUNet并没有提供其他平台的支持。nnUNet是基于Python和PyTorch。所以首先得安装这两个，这里推荐使用Anaconda安装。具体步骤如下： 查看一下系统是否已经安装完Anaconda环境。在终端中直接输入conda，然后回车。如果出现下面字样以及一堆使用方法，则环境已存在conda无需安装Anaconda。直接跳至第二步。如果提示命令不存在，则参考https://blog.csdn.net/lwgkzl/article/details/89329383。（记得安装最新的版本！） 装完conda，然后新建一个环境，专门用于nnUNet。 conda create --name nnunet python=3.8 然后激活这个环境。（之后如果新开终端，每次都要激活环境） conda activate nnunet 详细的conda手册参考：https://docs.conda.io/projects/conda/en/4.6.1/user-guide/tasks/manage-environments.html#creating-an-environment-with-commands 安装PyTorch。终端输入以下命令 conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c conda-forge check一下是否成功。 如果能正确输出，则pytorch安装正确，且能使用GPU加速。 在这个环境中安装nnUNet。终端中输入以下命令即可。（也可以使用csdn上的教程中的那种安装方式) pip install nnunet check一下是否成功 如果能import nnunet正常输出，则nnUNet安装正确。而且输入which nnUNet_train 会有输出 ","date":"2021-03-14","objectID":"/nnunet-0/:1:0","tags":["Python"],"title":"nnUNet 使用不完全指南（上）","uri":"/nnunet-0/"},{"categories":["学习笔记"],"content":"用nnUNet训练自己的数据 设置环境变量。 在合适的地方新建如下三个文件夹，分别存放预处理后的图像，原始的图像和训练完成的模型。 修改Home目录下的.bashrc文件，在最后加入下面内容(!注意这三个目录应该是对应自己的) export nnUNet_raw_data_base=\"/media/fabian/nnUNet_raw\" export nnUNet_preprocessed=\"/media/fabian/nnUNet_preprocessed\" export RESULTS_FOLDER=\"/media/fabian/nnUNet_trained_models\" 保存之后，在终端中输入以下命令 source ~/.bashrc 整理数据 nnUNet 对数据的命名和结构都有严格的要求，需要调整自己的数据才能给nnUNet使用。在上面新建的nnUNet_raw下面再新建nnUNet_raw_data文件夹。然后在nnUNet_raw_data下新建文件 TaskXXX_任务名。 XXX是任务序号(大于100的数，前100被占用了)，任务名取一个好记的英文名。 最后的文件结构如下 nnUNet_raw/nnUNet_raw_data/ ├── Task001_BrainTumour ├── Task002_Heart ├── Task003_Liver ├── Task004_Hippocampus ├── Task005_Prostate ├── ... 然后在任务文件夹里构建如下结构 Task001_BrainTumour/ ├── dataset.json ├── imagesTr ├── (imagesTs) └── labelsTr imagesTr 和 labelsTr 分别存放训练的原图和标签。imagesTs存放测试的原图。dataset.json 下面会说。 图像命名 imagesTr 和 labelsTr 中图像的命名也有要求。其中imagesTr需要改成类似下图这样，而且必须是 .nii.gz 格式。建议写个 python 脚本批量重命名并保存成 .nii.gz 格式。 labelsTr需要改成如下样式，注意原图和标签图序号一一对应，只是原图后面带**_0000**。 imagesTs改成如下，无需从0开始标号，可以接着训练集继续标下去，比较方便。 dataset.json编写 上文说到这个任务文件夹应该包含一个dataset.json 文件。下面是一个例子 { \"description\": \"Task128_LungLobe\", \"labels\": { \"0\": \"0\", \"1\": \"1\", \"2\": \"2\", \"3\": \"3\", \"4\": \"4\", \"5\": \"5\" }, \"licence\": \"see challenge website\", \"modality\": { \"0\": \"CT\" }, \"name\": \"Task128_LungLobe\", \"numTest\": 6, \"numTraining\": 80, \"reference\": \"see challenge website\", \"release\": \"0.0\", \"tensorImageSize\": \"4D\", \"test\": [ \"./imagesTs/LungLobe_080.nii.gz\", \"./imagesTs/LungLobe_081.nii.gz\", \"./imagesTs/LungLobe_082.nii.gz\", \"./imagesTs/LungLobe_083.nii.gz\", \"./imagesTs/LungLobe_084.nii.gz\", \"./imagesTs/LungLobe_085.nii.gz\" ], \"training\": [ { \"image\": \"./imagesTr/LungLobe_000.nii.gz\", \"label\": \"./labelsTr/LungLobe_000.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_001.nii.gz\", \"label\": \"./labelsTr/LungLobe_001.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_002.nii.gz\", \"label\": \"./labelsTr/LungLobe_002.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_003.nii.gz\", \"label\": \"./labelsTr/LungLobe_003.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_004.nii.gz\", \"label\": \"./labelsTr/LungLobe_004.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_005.nii.gz\", \"label\": \"./labelsTr/LungLobe_005.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_006.nii.gz\", \"label\": \"./labelsTr/LungLobe_006.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_007.nii.gz\", \"label\": \"./labelsTr/LungLobe_007.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_008.nii.gz\", \"label\": \"./labelsTr/LungLobe_008.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_009.nii.gz\", \"label\": \"./labelsTr/LungLobe_009.nii.gz\" }, { \"image\": \"./imagesTr/LungLobe_010.nii.gz\", \"label\": \"./labelsTr/LungLobe_010.nii.gz\" } ] } 按自己的任务的属性，修改上面的labels，numTest等等信息。注意：这里image的文件名里没有 _0000 。但是修改这个json文件夹的工作量是比较大的，也可以写个 python 脚本自动生成。下面是例子 from collections import OrderedDict from batchgenerators.utilities.file_and_folder_operations import save_json def main(): foldername = \"Task128_LungLobe\" numTraining = 80 numTest = 6 numClass = 6 json_dict = OrderedDict() json_dict['name'] = foldername json_dict['description'] = foldername json_dict['tensorImageSize'] = \"4D\" json_dict['reference'] = \"see challenge website\" json_dict['licence'] = \"see challenge website\" json_dict['release'] = \"0.0\" json_dict['modality'] = { \"0\": \"CT\", } json_dict['labels'] = {i: str(i) for i in range(numClass)} json_dict['numTraining'] = numTraining json_dict['numTest'] = numTest json_dict['training'] = [{'image': \"./imagesTr/LungLobe_{:0\u003e3d}.nii.gz\".format(i), \"label\": \"./labelsTr/LungLobe_{:0\u003e3d}.nii.gz\".format(i)} for i in range(numTraining)] json_dict['test'] = [\"./imagesTs/LungLobe_{:0\u003e3d}.nii.gz\".format(i) for i in range(numTraining, numTraining+numTest)] save_json(json_dict, \"./dataset.json\") if __name__ == \"__main__\": main() 需要发挥一点主观能动性，修改一下使之适应自己的任务。 整理完数据，运行下面命令 nnUNet_plan_and_preprocess -t XXX --verify_dataset_integrity XXX 代替为你的任务序号。该命令进行预处理。 开始训练。 单卡训练：执行 nnUNet_train 3d_fullres nnUNetTrainerV2 XXX 0 意思是对序号为XXX的任务进行第0折交叉验证，训练模式是3d的全像素。一共有五折交叉验证，所以最后一个数为0-4。 注意：默认在第一块 gpu（索引为0）上进行训练，如果想指定某个gpu，请先执行： export CUDA_VISIBLE_DEV","date":"2021-03-14","objectID":"/nnunet-0/:2:0","tags":["Python"],"title":"nnUNet 使用不完全指南（上）","uri":"/nnunet-0/"},{"categories":["折腾指南"],"content":"Python 作为一种脚本代码，不需要配置复杂的编译环境，而 Vim 具有优秀的英文编辑能力，使用Vim编辑Python是非常不错的选择。科学计算使用 Anaconda 构建虚拟的 Python 环境，这和普通的 pyenv 有点不同，本文将介绍在服务器中使用 Vim 进行 Python 科学计算编程。 ","date":"2020-11-26","objectID":"/vim_python/:0:0","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"Anaconda \u0026\u0026 Miniconda 安装 Anaconda 提供了虚拟环境管理的命令 conda 。不同项目所需要的 python环境是不同的，不同包直接解决依赖问题十分复杂，使用conda可以轻松的管理。 国内用户可以使用(anaconda | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror) 进行安装。并按照它的教程，更换conda的源。Miniconda是Anaconda的精简版，如果你像我一样，不喜欢Anaconda带的多余的包，可以使用Miniconda，其安装方式和Anaconda相似。 正确安装后，应该得到类似如下的结果： 可以看到conda被加入了环境变量，运行python时，也是使用的Anaconda虚拟环境中的Python。 ","date":"2020-11-26","objectID":"/vim_python/:1:0","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"Vim \u0026\u0026 NeoVim 配置 如果想要舒服的Vim体验，请先升级到Vim 8.0以上，并且支持clipboard和python3，可以使用vim –version查看。 如图，就是没有支持clipboard但支持了python3。当然还有另外一种选择，那就是NeoVim。NeoVim就没这么多限制了，装了就ok了。 ","date":"2020-11-26","objectID":"/vim_python/:2:0","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"插件安装 使用vim-plug进行插件管理，按照其Github上的ReadMe进行安装。 sh -c 'curl -fLo \"${XDG_DATA_HOME:-$HOME/.local/share}\"/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim' 然后在NeoVim的配置文件(~/.config/nvim/init.vim)中加入以下的代码： \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"Plug Install list\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" set nocompatible \" required filetype off \" required call plug#begin('~/.vim/plugged') Plug 'neoclide/coc.nvim', {'branch': 'release'} Plug 'Yggdroot/indentLine' Plug 'mhinz/vim-signify' \"显示修改痕迹 Plug 'honza/vim-snippets' Plug 'scrooloose/nerdcommenter' \"\u003cLeader\u003ec\u003cspace\u003e 注释当前行或者反注释 Plug 'rhysd/clever-f.vim' Plug 'kien/rainbow_parentheses.vim' Plug 'Raimondi/delimitMate' \"shift-tab 跳出匹配的闭括号 Plug 'chiel92/vim-autoformat' Plug 'mhinz/vim-startify' if has('nvim') Plug 'Shougo/defx.nvim', { 'do': ':UpdateRemotePlugins' } else Plug 'Shougo/defx.nvim' Plug 'roxma/nvim-yarp' Plug 'roxma/vim-hug-neovim-rpc' endif Plug 'skywind3000/asyncrun.vim' Plug 'skywind3000/asynctasks.vim' Plug 'wellle/tmux-complete.vim' call plug#end() 然后打开 NeoVim，执行命令 :PlugInstall 。自动安装所需的插件。装完也许会提示你一些工具没有安装，比如 node、npm等，需要进行安装。 同时加入 let g:python3_host_prog = \"/home/kissandrun/miniconda3/bin/python\" 指定python host的位置，同时需要 pip install neovim 这时，在NeoVim中执行 :checkhealth时，python3 显示满足依赖。其他 python2 啥的不用管。 ","date":"2020-11-26","objectID":"/vim_python/:2:1","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"自动补全 使用Coc作为自动补全的框架。在上面过程中，我们已经安装了Coc。安装coc-python、coc-snippets。 安装方法如下： :CocInstall coc-python coc-snippets 进行Coc的配置，配置方法如下 :CocConfig 他会自动打开配置文件，将下面内容复制进去。 { \"python.linting.pylintEnabled\": false, \"python.linting.flake8Enabled\": true, \"python.linting.flake8Path\": \"/home/kissandrun/miniconda3/bin/flake8\", \"python.linting.flake8Args\": [\"--ignore=E126,E123,E24,E203,E501,W504,E402\", \"--verbose\"], \"python.jediEnabled\": true, \"python.jediPath\": \"/home/kissandrun/miniconda3/lib/python3.8/site-packages/\", \"python.linting.enabled\": true } Jedi安装 Coc的补全依赖于Jedi，安装方式如下： conda install jedi 然后修改上面的Coc配置文件，将我的Jedi目录换成你的，只要指定到site-packages即可。 效果展示 如图后面带 [JD] 的就是来自jedi的补全。 上面的配置还应该能够同时补全snippet和tmux中的内容。 Coc正确识别conda环境 使用conda时Coc好像不能正确识别python环境，需要在vim配置文件中加入如下： if $CONDA_PREFIX == \"\" let s:current_python_path=$CONDA_PYTHON_EXE else let s:current_python_path=$CONDA_PREFIX.'/bin/python' endif call coc#config('python', {'pythonPath': s:current_python_path}) ","date":"2020-11-26","objectID":"/vim_python/:2:2","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"代码检查 代码检查也依赖于Coc框架。我使用flake8进行代码检查。上面的Coc配置文件中已经写了。需要指定Flake8的安装路径，如果没有安装，可以使用如下代码安装： conda install flake8 效果如下图所示： ","date":"2020-11-26","objectID":"/vim_python/:2:3","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"代码格式化 代码格式化使用 vim-autoformat 插件，在上面已经安装过了，该插件可以使用yapf，black等命令行工具对代码进行格式化，我的选择是black。 在vim配置文件中加入下面几行就可以完成设置： noremap \u003cleader\u003eaf :Autoformat\u003cCR\u003e let g:formatters_python = ['black'] 映射leader af 为格式化代码。 ","date":"2020-11-26","objectID":"/vim_python/:2:4","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"代码执行 深度学习的代码执行一般都是使用网络进行训练或者预测，所以建议新开一个tmux的窗口直接运行代码，而不在编辑器中运行。如果是小的python脚本，可以使用： Plug 'skywind3000/asyncrun.vim' Plug 'skywind3000/asynctasks.vim' 这两个插件实现。配置方法如下： 新建 .config/nvim/tasks.ini, 写入如下内容 [file-run] command=\"$(VIM_FILEPATH)\" command:c,cpp=\"$(VIM_PATHNOEXT)\" command:go=\"$(VIM_PATHNOEXT)\" command:python=ipython -i \"$(VIM_FILENAME)\" command:make=make -f \"$(VIM_FILENAME)\" run command:emake=emake -e \"$(VIM_FILENAME)\" command:javascript=node \"$(VIM_FILENAME)\" command:sh=sh \"$(VIM_FILENAME)\" command:lua=lua \"$(VIM_FILENAME)\" command:perl=perl \"$(VIM_FILENAME)\" command:ruby=ruby \"$(VIM_FILENAME)\" command:zsh=zsh \"$(VIM_FILENAME)\" command:bash=bash \"$(VIM_FILENAME)\" command:fish=fish \"$(VIM_FILENAME)\" command:php=php \"$(VIM_FILENAME)\" command:erlang=escript \"$(VIM_FILENAME)\" command:ps1=powershell -file \"$(VIM_FILENAME)\" command:scala=scala \"$(VIM_FILENAME)\" command:haskell=ghci \"$(VIM_FILENAME)\" command:applescript=osascript \"$(VIM_FILENAME)\" command:vim=:source % output=terminal cwd=$(VIM_FILEDIR) save=2 将python文件的执行命令设置为ipython，当然也可以设置为python，ipython方便查看变量，更适应科学计算需求。 然后在vim配置文件中加入如下配置 let g:asyncrun_rootmarks = ['.svn', '.git', '.root', '_darcs', 'build.xml'] \" 自动打开 quickfix window ，高度为 6 let g:asyncrun_open = 6 \" 任务结束时候响铃提醒 let g:asyncrun_bell = 1 let g:asynctasks_term_pos = 'bottom' noremap \u003csilent\u003e\u003cf5\u003e :AsyncTask file-run\u003ccr\u003e 这样设置之后，F5被设置为运行各种类型代码的快捷键。 ","date":"2020-11-26","objectID":"/vim_python/:2:5","tags":["Vim","Python"],"title":"使用Vim进行Python科学计算编程","uri":"/vim_python/"},{"categories":["折腾指南"],"content":"平时科学上网时，一般的流程都是这样的，在一个客户端中配置你的V2ray，Trojan信息，然后客户端会设置一个本地的监听端口，常用的比如1080端口，10808端口等等。常用的协议比如socks5或者http。如果你没有设置全局代理，那么此时你是无法科学上网的，一些软件提供了监听这些端口的功能，这样这个软件就可以科学上网了。 以V2rayN这个客户端为例， 可以看到他设置了10808端口为本地监听端口。 如上图就是Telegram使用本地Socks5的10808端口进行科学上网的设置。 ","date":"2020-11-25","objectID":"/git_speedup/:0:0","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"WSL使用本地代理 Windows Subsystem for Linux 和 Windows 是共享端口的，也就是Windows的10808端口和WSL 的10808端口是同一个，所以使用这个端口便可以给WSL进行科学上网和Git加速。 ","date":"2020-11-25","objectID":"/git_speedup/:1:0","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"proxychains 进行命令行加速 proxychains是一个可以让你的命令通过代理运行的linux命令。安装方法如下： sudo apt install proxychains 安装完之后需要对其进行配置，编辑 /etc/proxychains.conf文件。修改最后一行为如下： [ProxyList] # add proxy here ... # meanwile # defaults set to \"tor\" socks5 127.0.0.1 10808 然后你只需要在平时的命令前加上proxychains 就可以了，比如 proxychains git clone ……… ","date":"2020-11-25","objectID":"/git_speedup/:1:1","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"设置ALL_PROXY变量进行加速 在 .zshrc 或者 .bashrc 中加入如下两行： alias setproxy=\"export ALL_PROXY=socks5://127.0.0.1:10808\" alias unsetproxy=\"unset ALL_PROXY\" 然后当你要给终端命令科学上网时，只要先运行setproxy就行了。但这种方法只对走http协议的生效。比如curl，wget等，而对于走SSH协议的 git clone git@... 是无效的。 ","date":"2020-11-25","objectID":"/git_speedup/:1:2","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"git clone下载加速 git是常用的版本控制的工具，也是从github，gitlab上下载代码的利器。每天几乎都会git clone 和 git push。但是由于github的服务器不在中国，上传下载十分缓慢，不得不进行科学上网。 ","date":"2020-11-25","objectID":"/git_speedup/:2:0","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"加速SSH协议 git clone git@xxxxxxxx 走的其实就是SSH协议，所以只要对SSH进行配置就可以了。 编辑 ～/.ssh/config 文件，如果不存在就新建。 加入如下代码 Host github.com HostName github.com User git ProxyCommand nc -X 5 -x 127.0.0.1:10808 %h %p 使用代理进行连接。这里使用到了工具nc如果没有安装需要提前安装，不过系统一般都会自带。 如果你 git clone 不是github，而是一个你自己搭建在国外服务器上的git服务器，也可以通过配置进行加速。在上面那个文件加入下面的代码，将Host改成服务器ip，就能起到加速作用。 Host 104.168.*.* ProxyCommand nc -X 5 -x 127.0.0.1:10808 %h %p ","date":"2020-11-25","objectID":"/git_speedup/:2:1","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"加速HTTP协议 在终端中输入下面两行命令就可以了。 git config --global http.proxy 'socks5://127.0.0.1:10808' git config --global https.proxy 'socks5://127.0.0.1:10808' ","date":"2020-11-25","objectID":"/git_speedup/:2:2","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"最好的方法 最好的最优雅的方法当然是使用软路由。只要一个软路由，就可以全家科学上网，无需再各个设备上分别设置。 ","date":"2020-11-25","objectID":"/git_speedup/:3:0","tags":["WSL","Git"],"title":"WSL使用本地代理和git clone加速","uri":"/git_speedup/"},{"categories":["折腾指南"],"content":"为什么不用Bash和Fish Bash是很多Linux发行版的默认shell，但是显然他不是一个最佳的选择，单颜值不够高一条就足以把它抛弃了。当我们厌烦了Bash的陈旧愚钝，自然是要去找更加智能更加顺手的工具。Fish和Zsh是两个热度很高的Bash替代者。Fish有个致命的缺点就是他不兼容Bash，这或多或少产生一些问题。经过了两个月试用Fish后，我果断抛弃了，重新回到了Zsh的怀抱。然而这次我没有选择Oh-My-Zsh这个非常火的高度集成Zsh配置，而是找到了Zinit。 ","date":"2020-11-24","objectID":"/shell-3/:0:1","tags":["Shell"],"title":"Zsh \u0026 Zinit 配置舒服的终端环境","uri":"/shell-3/"},{"categories":["折腾指南"],"content":"为什么不用Oh-My-Zsh 当你在Google上搜索Zsh配置时，百分之九十的人都会让你一起装上Oh-My-Zsh，作为一个用了几年OMZ的人，我必须说它实在有点慢，使用OMZ打开终端竟然需要一两秒的时间。因为OMZ装了太多我不需要的插件了，他显得太臃肿。在我写这篇文章时，我又搜索了一下，看见这位博主对OMZ做了优化，提升了打开速度。我就感觉到快 —— zsh 和 oh my zsh 冷启动速度优化 | Sukka’s Blog (skk.moe)感兴趣的也可以试试优化。 但我要说的不是优化，而是直接抛弃OMZ，使用Zinit。它是一个插件管理器，可以管理你的插件，只安装那些有用的插件。那速度不就快了吗。而且Zinit可以安装OMZ里面的一些插件，只把你里面好用的拿过来装，简直杀人猪心。 ","date":"2020-11-24","objectID":"/shell-3/:0:2","tags":["Shell"],"title":"Zsh \u0026 Zinit 配置舒服的终端环境","uri":"/shell-3/"},{"categories":["折腾指南"],"content":"Zinit安装及配置 Zinit的项目地址是:https://github.com/zdharma/zinit 官方推荐的安装方法为： sh -c \"$(curl -fsSL https://raw.githubusercontent.com/zdharma/zinit/master/doc/install.sh)\" 他会安装在你的home目录，生成一个.zinit的文件夹。 我的配置 下面是我的配置，基本只留了一些我需要的插件。将其复制到.zshrc然后source一下就可以了。 # 语法高亮 zinit ice lucid wait='0' atinit='zpcompinit' zinit light zdharma/fast-syntax-highlighting # 自动建议 zinit ice lucid wait=\"0\" atload='_zsh_autosuggest_start' zinit light zsh-users/zsh-autosuggestions # 补全 zinit ice lucid wait='0' zinit light zsh-users/zsh-completions # 加载 OMZ 框架及部分插件 zinit snippet OMZ::lib/completion.zsh zinit snippet OMZ::lib/history.zsh zinit snippet OMZ::lib/theme-and-appearance.zsh zinit snippet OMZ::plugins/autojump/autojump.plugin.zsh zinit snippet OMZ::plugins/command-not-found/command-not-found.plugin.zsh zinit load djui/alias-tips 这些插件基本是够用的，再配合一些快捷键就能高效进行终端操作了。常用的快捷键：Ctrl-A回到命令最开始。Ctrl-E回到命令末尾。C-f补全命令 速度测试 ","date":"2020-11-24","objectID":"/shell-3/:0:3","tags":["Shell"],"title":"Zsh \u0026 Zinit 配置舒服的终端环境","uri":"/shell-3/"},{"categories":["折腾指南"],"content":"作为一个炼丹术士，操作服务器是家常便饭，如何高效的操作服务器，管理环境，运行代码便成了头等大事。炼的好不好先不说，得先炼得舒服。 常用的方法无非以下几种： 利用远程桌面（teamviewer，VNC 等工具）全程 GUI 操作 利用本地端的 IDE（如 Pycharm）或者代码编辑器（如 VS Code 等）写代码，然后利用他们的 Remote Tools 进行代码上传等 SSH 到远程服务器，全程 CLI 操作 三种方法各有优劣，但如果兼顾效率与 Geek，那第三种方法真是 Awesome 到不行。 我的工作流是： SSH 到远程服务器 新建 Tmux 会话，或者 attach 之前的会话 使用 Vim 编辑代码，以及其他命令行工具 使用 Anaconda 虚拟环境中 python 进行炼丹 ","date":"2020-11-22","objectID":"/myworkflow/:0:0","tags":["Vim","Tmux"],"title":"SSH+Tmux+Vim: 简单高效 Geek 的工作流","uri":"/myworkflow/"},{"categories":["折腾指南"],"content":"SSH 如果你操作远程服务器，那你一定接触过 SSH，如果没有那一定是没到家。windows的powershell和几乎所有的Linux发行版都自带SSH，可以在终端中使用。 常用的命令是 ssh user@domain.com Windows下也可以使用PuTTY等工具使用SSH。这里不得不再推荐一下Windows Subsystem for Linux因为服务器是Linux系统，统一一下环境岂不美哉。 更多 ssh 配置关键字 [‘ssh 免密登录’] ","date":"2020-11-22","objectID":"/myworkflow/:1:0","tags":["Vim","Tmux"],"title":"SSH+Tmux+Vim: 简单高效 Geek 的工作流","uri":"/myworkflow/"},{"categories":["折腾指南"],"content":"Tmux 终端复用 单使用 SSH 是不够的，因为如果你要同时运行多个命令，就需要开多个终端，那是非常复杂难以管理的，Tmux 就因此而诞生了，它可以让你在一个终端里面模拟出多个终端。不仅如此，它还可以让你的程序始终处于运行状态，不管终端是否关闭，只要你的 Tmux 进程没有停止。 试想这样一个情形，你用 Pycharm 写了代码，并上传到了服务器，利用 Pycharm 的终端开始了训练，这时你不小心把 Pycharm 关了，或者突然断电了，或者 Win10 又蓝屏又重启更新了，那你的训练就强制停止了。 而如果你是在 Tmux 里的训练的，那没有任何问题，你只要重新 attach 回之前的那个 session 就行。 ","date":"2020-11-22","objectID":"/myworkflow/:2:0","tags":["Vim","Tmux"],"title":"SSH+Tmux+Vim: 简单高效 Geek 的工作流","uri":"/myworkflow/"},{"categories":["折腾指南"],"content":"安装 Tmux 首先先确认一下是否安装 Tmux，直接在终端输入tmux如果提醒命令没找到就使用sudo apt install tmux安装 tmux。然后再在终端输入tmux就可以建立一个新的会话。详细的tmux教程可以看 Tmux 使用教程 ","date":"2020-11-22","objectID":"/myworkflow/:2:1","tags":["Vim","Tmux"],"title":"SSH+Tmux+Vim: 简单高效 Geek 的工作流","uri":"/myworkflow/"},{"categories":["折腾指南"],"content":"舒服的配置 修改 prefix 键 默认的 prefix 键是Ctrl+b键，也就是先按 prefix 键再加一个键组成完整的快捷键。Ctrl+b很难按的，即使是交换了 Ctrl 和 CapsLock 键之后依旧很难按。可以在配置文件~/.tmux.conf里加入下面这行 bind C-f send-prefix -2 添加新的 prefix 键Ctrl-f 分屏 默认的快捷键我忘了，但下面这个配置你肯定看了就不会忘。 bind - splitw -v -c '#{pane_current_path}' # 垂直方向新增面板，默认进入当前目录 bind \\ splitw -h -c '#{pane_current_path}' # 水平方向新增面板，默认进入当前目录 使用prefix+-上下分屏；使用prefix+\\左右分屏，因为上下分屏就是加一条横线（-），左右分屏就是加一条竖线（|也就是、键）。这样就不会忘了。 如何与 Vim 联动 tmux 可以分屏，Vim 也可以分出多个窗口，那么怎样在 tmux 和 vim 之间来回切换呢。 在 Google 中键入 vim 和 tmux 两个关键词出来的第一条就是 christoomey/vim-tmux-navigator。在 vim 中安装此插件，并在。vimrc 和。tmux.conf 中分别添加相应的设置即可（详见此插件的 README）。 按照 README 的配置完后可以使用Ctrl加hjkl进行窗口的切换。 另一个插件 wellle/tmux-complete.vim 可以让你补全 tmux 里面的内容。 ","date":"2020-11-22","objectID":"/myworkflow/:2:2","tags":["Vim","Tmux"],"title":"SSH+Tmux+Vim: 简单高效 Geek 的工作流","uri":"/myworkflow/"},{"categories":["折腾指南"],"content":"总结 这套工作流可以全键盘操作，极其优雅 Geek 上手难度有点高，不过完全值得 无 GUI 没办法看图 ","date":"2020-11-22","objectID":"/myworkflow/:3:0","tags":["Vim","Tmux"],"title":"SSH+Tmux+Vim: 简单高效 Geek 的工作流","uri":"/myworkflow/"},{"categories":null,"content":"ℹ️ 关于本站 这是一个基本没有人访问的博客，如果你能看到这篇关于我，那可真是太神奇了。本博客的目的是记录我的生活和科研，里面的内容可能是原创的，有部分也有可能是转载的（转载部分我会放置在 Notion页面下），如果侵害了您的权益，我会及时删除。 本博客使用Hugo搭建，使用的主题是LoveIt。 ","date":"2020-11-04","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"👨 我是谁 我是一个研究医学图像的炼丹师，欢迎和我一起交流探讨高阶炼丹术。 ","date":"2020-11-04","objectID":"/about/:2:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"📫 友链 Yang's Blog 幼儿园毕业的研究生 Qinzhu Qinzhu's Blog ","date":"2020-11-04","objectID":"/about/:3:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["折腾指南"],"content":"macOS下有很多优秀的软件，极大的提升了生产力。人们提到Windows系统下的软件，第一感觉可能是：多而乱，良莠不齐。而且由于不少国产软件的荼毒，Windows下经常出现弹窗，广告等等。但是，大人，时代变了。Windwos下其实有很多优秀的软件，而且只要避免使用垃圾国产软件，Windwos的纯净程度不低于macOS。 ","date":"2020-06-24","objectID":"/app-0/:0:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"AutoHotKey 自动化神器 AutoHotKey 是 Windows 下的一款自动化神器。第一次接触这款软件是为了实现设置快捷键的需求，后来又了解了一些这款软件的其他功能。可以说，目前为止，我都没有发挥这款软件的最大功效，但已经帮我解决了一些问题。 ","date":"2020-06-24","objectID":"/app-0/:1:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"Windows下虚拟桌面的切换问题。 系统自带的虚拟桌面切换快捷键十分难按，而且只能在左右两个虚拟桌面之间切换，也就是说如果你要从第一个虚拟桌面切换至第三个虚拟桌面就要按两次快捷键。这是十分不方便的。使用 AutoHotKey 可以解决这个问题。 ; Globals DesktopCount = 2 ; Windows starts with 2 desktops at boot CurrentDesktop = 1 ; Desktop count is 1-indexed (Microsoft numbers them this way) ; ; This function examines the registry to build an accurate list of the current virtual desktops and which one we're currently on. ; Current desktop UUID appears to be in HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\1\\VirtualDesktops ; List of desktops appears to be in HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VirtualDesktops ; mapDesktopsFromRegistry() { global CurrentDesktop, DesktopCount ; Get the current desktop UUID. Length should be 32 always, but there's no guarantee this couldn't change in a later Windows release so we check. IdLength := 32 SessionId := getSessionId() if (SessionId) { RegRead, CurrentDesktopId, HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\%SessionId%\\VirtualDesktops, CurrentVirtualDesktop if (CurrentDesktopId) { IdLength := StrLen(CurrentDesktopId) } ; Get a list of the UUIDs for all virtual desktops on the system RegRead, DesktopList, HKEY_CURRENT_USER, SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VirtualDesktops, VirtualDesktopIDs if (DesktopList) { DesktopListLength := StrLen(DesktopList) ; Figure out how many virtual desktops there are DesktopCount := DesktopListLength / IdLength } else { DesktopCount := 1 } ; Parse the REG_DATA string that stores the array of UUID's for virtual desktops in the registry. i := 0 while (CurrentDesktopId and i \u003c DesktopCount) { StartPos := (i * IdLength) + 1 DesktopIter := SubStr(DesktopList, StartPos, IdLength) OutputDebug, The iterator is pointing at %DesktopIter% and count is %i%. ; Break out if we find a match in the list. If we didn't find anything, keep the ; old guess and pray we're still correct :-D. if (DesktopIter = CurrentDesktopId) { CurrentDesktop := i + 1 OutputDebug, Current desktop number is %CurrentDesktop% with an ID of %DesktopIter%. break } i++ } } ; ; This functions finds out ID of current session. ; getSessionId() { ProcessId := DllCall(\"GetCurrentProcessId\", \"UInt\") if ErrorLevel { OutputDebug, Error getting current process id: %ErrorLevel% return } OutputDebug, Current Process Id: %ProcessId% DllCall(\"ProcessIdToSessionId\", \"UInt\", ProcessId, \"UInt*\", SessionId) if ErrorLevel { OutputDebug, Error getting session id: %ErrorLevel% return } OutputDebug, Current Session Id: %SessionId% return SessionId } ; ; This function switches to the desktop number provided. ; switchDesktopByNumber(targetDesktop) { global CurrentDesktop, DesktopCount ; Re-generate the list of desktops and where we fit in that. We do this because ; the user may have switched desktops via some other means than the script. mapDesktopsFromRegistry() ; Don't attempt to switch to an invalid desktop if (targetDesktop \u003e DesktopCount || targetDesktop \u003c 1) { OutputDebug, [invalid] target: %targetDesktop% current: %CurrentDesktop% return } ; Go right until we reach the desktop we want while(CurrentDesktop \u003c targetDesktop) { send {LWin down}{LCtrl down}{Right}{LCtrl up}{LWin up} CurrentDesktop++ OutputDebug, [right] target: %targetDesktop% current: %CurrentDesktop% } ; Go left until we reach the desktop we want while(CurrentDesktop \u003e targetDesktop) { send {LWin down}{LCtrl down}{Left}{LCtrl up}{LWin up} CurrentDesktop-- OutputDebug, [left] target: %targetDesktop% current: %CurrentDesktop% } ToolTip, %CurrentDesktop%%CurrentDesktop%%CurrentDesktop%%CurrentDesktop%%CurrentDesktop%%CurrentDesktop%`n%CurrentDesktop%%CurrentDesktop%%CurrentDesktop%%CurrentDesktop%%CurrentDesktop%%CurrentDesktop% SetTimer, RemoveToolTip, -2000 return } RemoveToolTip: ToolTip return ; Main SetKeyDelay, 75 mapDesktopsFromRegistry() OutputDebug, [loading] desktops: %DesktopCount% current: %CurrentDesktop% ; User config! ; This section binds t","date":"2020-06-24","objectID":"/app-0/:1:1","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"快捷键快速启动应用 在Linux系统中，可以使用快捷键直接打开终端，很方便。但是在Windows中如果设置启动快捷键，只能使用Ctrl开头，和我习惯的Alt+Enter不符。可以使用 AutoHotKey 设置启动快捷键。 RunOrActivate(Target, WinTitle = \"\", Parameters = \"\") { ; Get the filename without a path SplitPath, Target, TargetNameOnly Process, Exist, %TargetNameOnly% If ErrorLevel \u003e 0 PID = %ErrorLevel% Else Run, %Target% \"%Parameters%\", , , PID ; At least one app (Seapine TestTrack wouldn't always become the active ; window after using Run), so we always force a window activate. ; Activate by title if given, otherwise use PID. If WinTitle \u003c\u003e { SetTitleMatchMode, 2 WinWait, %WinTitle%, , 3 WinActivate, %WinTitle% } Else { WinWait, ahk_pid %PID%, , 3 WinActivate, ahk_pid %PID% } } RunOrActivateMultiParam(Target, WinTitle = \"\", Param1 = \"\", Param2 = \"\", Param3 = \"\") { ; Get the filename without a path SplitPath, Target, TargetNameOnly Process, Exist, %TargetNameOnly% If ErrorLevel \u003e 0 PID = %ErrorLevel% Else Run, %Target% \"%Param1%\" \"%Param2%\" \"%Param3%\", , , PID ; At least one app (Seapine TestTrack wouldn't always become the active ; window after using Run), so we always force a window activate. ; Activate by title if given, otherwise use PID. If WinTitle \u003c\u003e { SetTitleMatchMode, 2 WinWait, %WinTitle%, , 3 WinActivate, %WinTitle% } Else { WinWait, ahk_pid %PID%, , 3 WinActivate, ahk_pid %PID% } } !Enter::RunOrActivateMultiParam(\"C:\\Program Files\\WSL-Terminal\\open-wsl.exe\",\"\",\"-C\",\"~\",\" \") ","date":"2020-06-24","objectID":"/app-0/:1:2","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"禁用 Win 键 我常常勿按 Win 键启动开始菜单，而且我认为用 Win 键启动开始在启动应用的方式十分的慢，不如使用 utools 启动。所以我直接禁用了 Win 键。实现方法也是 AutoHotKey 完成的。值得注意的是，只是禁用了 Win 键启动开始菜单的功能，而其作为修饰键的功能并不受影响。 LWin \u0026 vk07::return LWin::return RWin \u0026 vk07::return RWin::return ","date":"2020-06-24","objectID":"/app-0/:1:3","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"窗口管理 包括窗口最大化，最小化，关闭。Windows 当然自带了窗口管理的快捷键。如果没记错好像是 Win 键+方向键。但是使用方向键双手就会离开主键盘区，而且我的键盘没有方向键。所以我重新设置了快捷键。 !q:: SendInput {Alt Down}{F4}{Alt Up} Return #IfWinActive ahk_class Chrome_WidgetWin_1 !q::Send ^w #IfWinActive !j:: SendInput {LWin Down}{down}{LWin Up} Return #IfWinActive !k:: SendInput {LWin Down}{up}{LWin Up} Return 使用Alt+j最小化窗口，Alt+k最大化窗口，Alt+q关闭窗口。使用 Alt 修饰键实在是太方便了。 ","date":"2020-06-24","objectID":"/app-0/:1:4","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"utools + Everything utools 是逛 v2ex 时被安利的，它是一个快速启动+N 多实用功能的软件。使用 utools 之前，也是用过 wox，Listary 等工具，但当使用了 utool 是之后就没有换过了。当然它不是完美的，它占用的内存略大，第一次加载find功能时过慢，但这都不妨碍它是一个优秀的软件。在使用过程中我常使用快速启动和 find 插件。 ","date":"2020-06-24","objectID":"/app-0/:2:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"快速启动 如图，是 utools 的最基本功能，快速启动。只要输入软件的名称就可以快速启动。如果软件是绿色软件，也可以将快捷方式放置一个特定的文件夹，然后在 utool 是中设置添加该路径，同样可以快速启动。 ","date":"2020-06-24","objectID":"/app-0/:2:1","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"find 查找文件 在启动栏中输入 find 加空格之后可以激活 find 插件，它可以使用 Everything 作为后端，对文件进行查找。 如图所示，它提供了更好的界面。 ","date":"2020-06-24","objectID":"/app-0/:2:2","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"Rime 小狼毫输入法 虽然微软的自带输入法，已经能够应对百分之九十的输入环境，但是其不支持自定义快捷键，不支持加第三方词库。而国产的搜狗输入法经常出现弹窗广告，严重影响使用。所以推荐使用 Rime 小狼毫输入法。Rime 是一款开源的输入法，在各个平台都有，而且可以灵活的设置。 ","date":"2020-06-24","objectID":"/app-0/:3:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"为不同应用设置模式 很多软件我们希望进入的时候，使用英文输入，比如终端、utools、photoshop 等等。Rime 输入法可以实现这项功能。话说应该修改用户文件夹，我好像直接修改程序文件夹了，不过问题不大。修改程序文件夹下的data/weasel.yaml 文件，将一些程序设置为 ascii_mode。 app_options: pycharm64.exe: ascii_mode: true code.exe: ascii_mode: true explorer.exe: ascii_mode: true launchy.exe: ascii_mode: true photoshop.exe: ascii_mode: true lightroom.exe: ascii_mode: true windowsterminal.exe: ascii_mode: true utools.exe: ascii_mode: true mintty.exe: ascii_mode: true goldendict.exe: ascii_mode: true ","date":"2020-06-24","objectID":"/app-0/:3:1","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"设置习惯的快捷键 首先是用Shift临时切换中英模式，这个功能我很不喜欢，因为 shift 作为修饰键经常要按，但绝大多数的输入法都自带，Rime 也一样，但它可以通过设置去除。 编辑/data/default.yaml。修改如下： ascii_composer: good_old_caps_lock: true switch_key: Shift_L: noop Shift_R: noop Control_L: noop Control_R: noop Caps_Lock: clear Eisu_toggle: clear 然后是翻页，和选择。我希望使用[ ]进行翻页。使用tab进行预选项的选择。同样是修改上面的文件如下： key_binder: bindings: __patch: - key_bindings:/emacs_editing - key_bindings:/paging_with_brackets - key_bindings:/optimized_mode_switch 然后可以在，同文件夹的 key_bindings 文件具体修改每一项的快捷键，直到自己舒服为止。 ","date":"2020-06-24","objectID":"/app-0/:3:2","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"Windows Subsystem for Linux ✔️WSL2 折腾日记和使用体验报告 中已经写过了，不再说了。 ","date":"2020-06-24","objectID":"/app-0/:4:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"其他 懒癌犯了，剩下的一些大名顶顶，耳熟能详的软件直接放到其他里面了，包括： Visual Studio Code 虽然我是 Vim 党，但是中文输入真的不是 Vim 的擅长，推荐使用 VSC。 Office 365 办公神器，自带 1T Onedrive 空间。 坚果云 OneDrive 同步有些不稳定，坚果云是我使用过的国内最好的，就是价格略贵。 Google Chrome 估计我会专门写一篇。 Microsoft Edge 真香 Wallpaper Engine 动态壁纸，里面还有福利彩蛋。 火绒 自带的一些工具很好用 ","date":"2020-06-24","objectID":"/app-0/:5:0","tags":["Application","Windows"],"title":"👨‍💻Windows 下优秀软件推荐","uri":"/app-0/"},{"categories":["折腾指南"],"content":"疫情期间，迫于撰写毕业论文和大量的网络会议需求，我将自己的主力系统换到了 Windows 10，前几天又加入了预览者计划，更新到了最新的20H2 版本，该版本能够体验到最新的WSL2。**WSL2 据说相对于WSL1 有了很大的性能提升，尤其是I/O 性能。但对于我这个菜鸟使用者，估计是体验不出太大的差别。既然已经转移到了Windows 10 下面，那么体验一下WSL2 **是必须的。 ","date":"2020-06-23","objectID":"/wsl-0/:0:0","tags":["WSL","Windows"],"title":"✔️WSL2 折腾日记和使用体验报告","uri":"/wsl-0/"},{"categories":["折腾指南"],"content":"WSL2 的安装 **WSL2 **的安装网上教程太多了，就不赘述了，给个链接吧：https://docs.microsoft.com/en-us/windows/wsl/install-win10 有一点需要注意，网上很多教程都是安装完直接使用root 账户进行使用的，这样做能够极大方便使用，但也非常的危险，一般还是推荐使用非root 账户。至于 Linux 发行版的选择，我之前使用的是 ArchWSL, 这是一个第三方维护的 Arch 版本，使用完全没有问题，也能使用 Pacman 和 Aur，后来我使用的是官方维护的Ubuntu 20.04，安装软件相比于 Arch 麻烦一点，但毕竟是官方维护，用着更放心。 ","date":"2020-06-23","objectID":"/wsl-0/:1:0","tags":["WSL","Windows"],"title":"✔️WSL2 折腾日记和使用体验报告","uri":"/wsl-0/"},{"categories":["折腾指南"],"content":"终端的选择–wsl-terminal 至于终端的选择，我使用的是 wsl-terminal。至于为什么不使用微软新推出的 Windows Terminal，原因主要有以下几点： 渲染问题。使用 Windows Termianl 打开 Vim 时，四周会出现空白，和 Vim 的 Theme 不一致。而使用 wsl-terminal 则不会，wsl-terminal 具有和原本 Linux 系统相同的渲染。 当我使用 Windows Terminal 时，它还没有在该目录打开 Terminal 的功能，不过在最新的预览版中已经更新。 wsl-terminal 可以右击使用 WSL2 中的 Vim 打开文本文件，十分方便。 可以设置打开 wsl-terminal 的快捷键，可以使用 Autohotkey 脚本实现。 RunOrActivate(Target, WinTitle = \"\", Parameters = \"\") { ; Get the filename without a path SplitPath, Target, TargetNameOnly Process, Exist, %TargetNameOnly% If ErrorLevel \u003e 0 PID = %ErrorLevel% Else Run, %Target% \"%Parameters%\", , , PID ; At least one app (Seapine TestTrack wouldn't always become the active ; window after using Run), so we always force a window activate. ; Activate by title if given, otherwise use PID. If WinTitle \u003c\u003e { SetTitleMatchMode, 2 WinWait, %WinTitle%, , 3 WinActivate, %WinTitle% } Else { WinWait, ahk_pid %PID%, , 3 WinActivate, ahk_pid %PID% } } RunOrActivateMultiParam(Target, WinTitle = \"\", Param1 = \"\", Param2 = \"\", Param3 = \"\") { ; Get the filename without a path SplitPath, Target, TargetNameOnly Process, Exist, %TargetNameOnly% If ErrorLevel \u003e 0 PID = %ErrorLevel% Else Run, %Target% \"%Param1%\" \"%Param2%\" \"%Param3%\", , , PID ; At least one app (Seapine TestTrack wouldn't always become the active ; window after using Run), so we always force a window activate. ; Activate by title if given, otherwise use PID. If WinTitle \u003c\u003e { SetTitleMatchMode, 2 WinWait, %WinTitle%, , 3 WinActivate, %WinTitle% } Else { WinWait, ahk_pid %PID%, , 3 WinActivate, ahk_pid %PID% } } !Enter::RunOrActivateMultiParam(\"C:\\Program Files\\WSL-Terminal\\open-wsl.exe\",\"\",\"-C\",\"~\",\" \") 该程序还可以设置其他程序的打开快捷键，十分便利。 ","date":"2020-06-23","objectID":"/wsl-0/:2:0","tags":["WSL","Windows"],"title":"✔️WSL2 折腾日记和使用体验报告","uri":"/wsl-0/"},{"categories":["折腾指南"],"content":"使用fish作为 shell（我又换回去了，哈哈哈） 本次转移，还有一个重要的变化是，使用fish 代替原本的zsh + oh my zsh。替换的主要原因是，使用后者的启动速度过慢。作为一个菜鸟使用者，fish 并不兼容 Bash 的缺点根本无法感知，而fish 集成的语法高亮，输入提示等能够完全替代oh my zsh。 但是，必要的设置还是需要的，fish 的设置文件在~/.config/fish/config.fish set PATH \"/home/kissandrun/node/bin:$PATH\" set PATH \"/home/kissandrun/.local/bin:$PATH\" if test -f /home/kissandrun/.autojump/share/autojump/autojump.fish; . /home/kissandrun/.autojump/share/autojump/autojump.fish; end alias vim=nvim alias configfish=\"nvim /home/kissandrun/.config/fish/config.fish\" alias wcd=\"cd /mnt/c/Users/Run/\" # \u003e\u003e\u003e conda initialize \u003e\u003e\u003e # !! Contents within this block are managed by 'conda init' !! eval /home/kissandrun/anaconda3/bin/conda \"shell.fish\" \"hook\" $argv | source # \u003c\u003c\u003c conda initialize \u003c\u003c\u003c 其中可以加入一些 alias，和环境配置。 ","date":"2020-06-23","objectID":"/wsl-0/:3:0","tags":["WSL","Windows"],"title":"✔️WSL2 折腾日记和使用体验报告","uri":"/wsl-0/"},{"categories":["折腾指南"],"content":"个人使用的一些Tips 使用 WSL 后，一台电脑就相当于有两个 home 了，一个是 Win10 的 home 目录，一个是 wsl 中帐号的 home 目录，这两个目录并不是同一个，可以将 Win10 目录中的 Downloads 和 Document 使用ln -s命令链接到 wsl 中的 home 以方便进入，也可以 alias 进入各个 Win10 目录的命令。 可以在 windows 的 explorer 中将 home 目录放置在常用目录里面，方便进入。 **Visual Studio Code 和 JetBrains **已经很好的支持了 WSL。 在 wsl 中可以直接使用 windows 中的程序。比如在命令中输入explorer.exe .可以直接打开当前目录。输入命令code可以打开** Visual Studio Code**。 可以在 Vim 中设置，实现粘贴板的通信。 let s:clip = '/mnt/c/Windows/System32/clip.exe' if executable(s:clip) augroup WSLYank autocmd! autocmd TextYankPost * call system('echo '.shellescape(join(v:event.regcontents, \"\\\u003cCR\u003e\")).' | '.s:clip) augroup END end \" I thought this will be better :) noremap \u003cleader\u003ep :exe 'norm a'.system('/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe -Command Get-Clipboard')\u003cCR\u003e ","date":"2020-06-23","objectID":"/wsl-0/:4:0","tags":["WSL","Windows"],"title":"✔️WSL2 折腾日记和使用体验报告","uri":"/wsl-0/"},{"categories":["折腾指南"],"content":"使用的一些痛点 WSL 暂不支持systemd 想用的 Arch 发行版，没有官方的支持 粘贴板并不互通 打开速度可以更快 ","date":"2020-06-23","objectID":"/wsl-0/:5:0","tags":["WSL","Windows"],"title":"✔️WSL2 折腾日记和使用体验报告","uri":"/wsl-0/"},{"categories":["折腾指南"],"content":"不学个一个月就什么都学不会 本着这样的理念，决定推出每日学习计划每项学习任务的周期为一个月，坚持每日学习，每日码字。实验小白鼠为早就想学的 vim。 不积跬步无以至千里 本次计划遵循到红哥那偷零食吃的原则：少量多次 ","date":"2020-06-05","objectID":"/vim-0/:0:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day One ","date":"2020-06-05","objectID":"/vim-0/:1:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"在 vim 中打开文件 :e \u003cfilename\u003e打开名为 filename 的文件，若不存在则创建 :Ex 在 vim 中打开目录树，光标选中后回车打开对应文件，-进入上级目录 记忆：大概是 explorer 的意思 ","date":"2020-06-05","objectID":"/vim-0/:1:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"查找 /\u003csearch\u003e 向后查找指定的字符串 ?\u003csearch\u003e 向前查找指定的字符串 n 继续查找下一个 N 继续查找上一个 匹配查找： 可以用%对 (),[],{}进行匹配查找 ","date":"2020-06-05","objectID":"/vim-0/:1:2","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"移动光标 e 向右移动到单词结尾 记忆：end b 向左移动到单词开头 记忆：back 0 行首 $ 行尾 \u003cN\u003egg 跳转到第 N 行，gg 为到第一行 Ctrl-d 向下移动半页 Ctrl-u 向上移动半页 记忆：down and up ","date":"2020-06-05","objectID":"/vim-0/:1:3","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Two ","date":"2020-06-05","objectID":"/vim-0/:2:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"替换 :[addr]s/ 源字符串 / 目的字符串 /[option] , 其中 [addr][option] 是可以缺省不填的 [addr] 代表检索范围，常用的有%代表整个文件，1,10代表从 1 到 10 行，缺省为当前行 [option] 代表操作类型，缺省只对第一个匹配的字符替换，g 代表全局替换，c 代表替换时确认 几个例子： :s/aa/bb/g 将所在行出现的所有 aa 替换为 bb :%s/aa/bb/g 将文档中所有的包含 aa 的字符串替换为 bb :12,25s/aa/bb/g 将 12 行到 25 行中所有包含 aa 的字符替换为 bb :%s/^/#/ 全文的行首添加#字符 :%s= *$== 所有行尾多余的空格去除 :g/^$/d 删除所有空行 markdown 慎用 中间穿插点东西，作为一个 copy 党不和系统复制粘贴使用 vim 实在是太困难了，所以 google 了解决方法 复制到系统剪贴板 \"+y 系统剪贴板中复制 \"+p ","date":"2020-06-05","objectID":"/vim-0/:2:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"批量编辑文件 :argdo 『加命令』 例如：:argdo %s/xxx/yyy/g 对所有打开的文件进行查找替换 最后编辑完之后保存和关闭所有打开的文件 :wa :qa ","date":"2020-06-05","objectID":"/vim-0/:2:2","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Three ","date":"2020-06-05","objectID":"/vim-0/:3:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"自动补全 vim 自带的自动补全功能并不好用所以使用第三方的 YouCompleteMe 来完成自动补全的工作。YouCompleteMe 并不好装，折腾了一上午终于装完了 YouCompleteMe 默认只能自动你安装时候用的 Python Interpret, 如果要添加 Conda 或者 Virtualenv 中的 Python 环境，解决方法是在.ycm_extra_conf.py文件的最后写入以下内容 def Settings( **kwargs ): return { 'interpreter_path': '/path/to/virtual/environment/python' } YouCompleteMe 采用 Tab 键接受补全，一直按 Tab 键则会循环所有的匹配补全项，操作逻辑和 zsh 相似 参考：Vim 自动补全插件 YouCompleteMe 安装与配置 ","date":"2020-06-05","objectID":"/vim-0/:3:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"自动匹配括号 自动匹配括号采用第三方插件’Raimondi/delimitMate’完成 ","date":"2020-06-05","objectID":"/vim-0/:3:2","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Four ","date":"2020-06-05","objectID":"/vim-0/:4:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"多文件编辑 使用NERDTree插件结合 vim 的多文件编辑功能真的舒服的飞起 安装方法比较常规 在.vimrc文件中添加scrooloose/nerdtree 并且在.vimrc中添加如下的配置 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"NerdTree setting\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" map \u003cC-n\u003e :NERDTreeToggle\u003cCR\u003e autocmd StdinReadPre * let s:std_in=1 autocmd VimEnter * if argc() == 0 \u0026\u0026 !exists(\"s:std_in\") | NERDTree | endif autocmd bufenter * if (winnr(\"$\") == 1 \u0026\u0026 exists(\"b:NERDTree\") \u0026\u0026 b:NERDTree.isTabTree()) | q | endif 就能够更加舒服的使用，Ctrl-n 开关 Tree，当 Tree 是最后一个窗口的时候自动关闭 vim 其他快捷键有以下 选中目录 o打开目录 选中文件 o在当前窗口中直接打开文件 选中文件 s竖直分割窗口打开文件 i水平分割打开文件 t在新 tab 打开文件 C– Change the tree root to the selected dir NERDTREE 官方文档 在.vimrc中添加以下配置，切换 windows 更加快捷 \" Smart way to move between windows map \u003cC-j\u003e \u003cC-W\u003ej map \u003cC-k\u003e \u003cC-W\u003ek map \u003cC-h\u003e \u003cC-W\u003eh map \u003cC-l\u003e \u003cC-W\u003el ","date":"2020-06-05","objectID":"/vim-0/:4:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Buffer 运用 运用 Buffer 进行多文件管理能够更加高效（相比于 tab）；这好像是国外一群 vimer 交流讨论出来的结果 Buffer 缓冲区就是你用 vim 打开文件都会被写入缓冲区中，比如用NerdTree打开文件，不会加入 args 中，却会加入缓冲区； 重新 mapping 快捷键如下 \"\"\"\"\"\"\"\"\"\"\"\"\"\"buffer setting\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" set hidden \" 避免必须保存修改才可以跳转 buffer \" buffer 快速导航 nnoremap \u003cLeader\u003eb :bp\u003cCR\u003e nnoremap \u003cLeader\u003ef :bn\u003cCR\u003e \" 通过索引快速跳转 nnoremap \u003cLeader\u003e1 :1b\u003cCR\u003e nnoremap \u003cLeader\u003e2 :2b\u003cCR\u003e nnoremap \u003cLeader\u003e3 :3b\u003cCR\u003e nnoremap \u003cLeader\u003e4 :4b\u003cCR\u003e nnoremap \u003cLeader\u003e5 :5b\u003cCR\u003e nnoremap \u003cLeader\u003e6 :6b\u003cCR\u003e nnoremap \u003cLeader\u003e7 :7b\u003cCR\u003e nnoremap \u003cLeader\u003e8 :8b\u003cCR\u003e nnoremap \u003cLeader\u003e9 :9b\u003cCR\u003e nnoremap \u003cLeader\u003e0 :10b\u003cCR\u003e 当然 switch buffer 时还可以直接:b [pattern]直接切换，还可以用Tab补全 ","date":"2020-06-05","objectID":"/vim-0/:4:2","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Five ","date":"2020-06-05","objectID":"/vim-0/:5:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"快速移动 个人比较倾向于多 windows 多 buffer 的操作，比如屏幕包含三列 windows（nerdtree 加两个打开 buffer 的 windows） 所以最后的结果是多个 windows 共用一个 buffer 列表； 在单个 windows 中快速跳转除了基本的移动光标（如f t 以及hjkl等等）的方法之外还有以下方法 CTRL-O 和 CTRL-I 追踪光标的移动，可以回到光标以前的位置，甚至可以不是这个 buffer 搜索跳转 设置标志跳转（待学习 第一种使用** CTRL-O** 和 **CTRL-I **的方法其实是利用跳转表，:jumps可以查看。但是如果多 windows，因为各个 windows 跳转表不同，所以不能用这种方法在 window 之间切换； 一般，每次你执行一个会将光标移动到本行之外的命令，该移动即被称为一个 “跳转” 。这包括查找命令 “/” 和 “n” （无论跳转到多远的地方）。但不包括 “fx” 和 “tx” 这些行 内查找命令或者 “w” 和 “e” 等词移动命令。 —-vimdoc 同样也不包括\"j\" “k”; 切换 window 参考上文；其中添加一个命令到.vimrc map \u003cC-f\u003e \u003cC-W\u003e\u003cC-P\u003e 绑定快捷键 CTRL-F 用于切换到刚刚的那个 windows; 同一个 windows 中切换不同的 buffer 可以参考上面的内容； ","date":"2020-06-05","objectID":"/vim-0/:5:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Six ","date":"2020-06-05","objectID":"/vim-0/:6:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"可视模式 激活可视模式的方法有以下几种 命令 用途 v 激活面向字符的可视模式 V 激活面向行的可视模式 \u003cC-V\u003e 激活面向列的可视模式 gv 激活上次的高亮区块 进入可视模式后，可以用普通模式下移动光标的方法选定区域；可以使用A或者I在区域前或者后面添加内容； viw 可以快速选定一个 word; 之后可以对其进行y x c等操作 如果你在可视模式下选中了一些文字，然后你又发现你需要改变被选择的文字的另一端， 用 “o” 命令即可 （提示：“o” 表示 other end)，光标会移动到被选中文字的另一端，现 在你可以移动光标去改变选中文字的开始点了。再按 “o” 光标还会回到另一端。 ","date":"2020-06-05","objectID":"/vim-0/:6:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Text-object 经常使用ci( ci\"之类的命令，还有上面提到的viw命令；让我好奇 i 的含义 在 vim 中，指令的基本结构是 \u003cnumber\u003e\u003ccommand\u003e\u003ctext-object or motion\u003e 文本对象操作涉及到范围和操作，范围主要是主要是 i(inner ) 和 a(around)，文本对象有 w (word), s (sentence), p (paragraph), 和各种 引号和括号。 如果是 word 的话，i 只作用于字母，而 a 作用于 word 及其后面的空格； 如果是各种引号或者括号，i 只作用于括号内的内容，而 a 包括括号本身； 一篇很棒的文章 @todo args ","date":"2020-06-05","objectID":"/vim-0/:6:2","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Seven ","date":"2020-06-05","objectID":"/vim-0/:7:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Ex 模式中的 % normal 模式中%用于匹配括号等；在 Ex 模式中 %代表活动缓冲区的完整路径 :edit %\u003cTAB\\\u003e; 按 TAB 键可以将路径完整显示；而:edit %:h\u003cTAB\\\u003e :h 修饰符会去除文件名 :!mkdir -p %:h 就能够创造一个不存在的目录 ","date":"2020-06-05","objectID":"/vim-0/:7:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Eight ","date":"2020-06-05","objectID":"/vim-0/:8:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"寄存器 Vim 提供了 10 类共 48 个寄存器 一般来讲，可以用\"{register}y来拷贝到{register}中， 用\"{register}p来粘贴{register}中的内容。例如： \"ayy可以拷贝当前行到寄存器 a 中，而\"ap则可以粘贴寄存器 a 中的内容。 共有十种类型的寄存器： 无名寄存器 \"\" 10 个编号寄存器 “0 到 “9 行内删除寄存器 “- 26 个命名的寄存器 “a 到 “z 或者 “A 到 “Z 三个只读寄存器 “:、”. 和 “% 轮换缓冲区寄存器 “# 表达式寄存器 “= 选择和拖放寄存器 “*、\"+ 和 “~ 黑洞寄存器寄存器 “_ 最近搜索模式寄存器 “/ 其中 无名寄存器“”是缺省寄存器，编号寄存器\"0是拷贝寄存器，其他数字寄存器是大于一行的删除寄存器； ","date":"2020-06-05","objectID":"/vim-0/:8:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Day Nine ","date":"2020-06-05","objectID":"/vim-0/:9:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"Marks 设定一个标记，使用命令m{a-zA-Z}; 例如，命令mt在把当前光标位置设定为标记 t；命令mT把当前光标位置设定为标记 T。(:help m) 要跳转到指定的标记，使用命令'{a-zA-Z}或'{a-zA-Z}。例如，命令't会跳转到标记 t；命令'T会跳转到标记 T。 大写的标记可以在不同 buffer 之前跳转 使用:marks命令可以查看现有的 marks; 使用命令:delmarks可以删除指定标记 同样内置了几个 marks . 最近编辑的位置 0-9 最近使用的文件 ∧ 最近插入的位置 ' 上一次跳转前的位置 \" 上一次退出文件时的位置 [ 上一次修改的开始处 ] 上一次修改的结尾处 ","date":"2020-06-05","objectID":"/vim-0/:9:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"圣诞特辑 ","date":"2020-06-05","objectID":"/vim-0/:10:0","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"宏 很多时候使用 vim 重复一个命令，我们最先想到.命令，但点命令只能重复上一个命令如果要重复很多个命令就要使用宏录制 (macro) 录制宏，可以使用 q+[a-z] 26 个字母中的一个 q[a-z] 开始录制宏，结束时再摁一下q。 对的没错他用的就是前文所讲的字母寄存器。所以可以用查看 reg 的方法查看录制的宏:reg a; 录制完宏后，再寄存器名前加@，可以执行宏。 怎么编辑宏呢？ :let @a=’ 输入 Ctrl + r + a 来插入 a 中内容； 编辑内容然后以 ' 结束 Enter 退出 至此，基础的 vim 已经学的差不多了，或者说已经可以满足日常的使用了。所要做的就是实践和总结。 所以，本文就结束了，今后实践和总结所得将会写在新的文章中。祝自己圣诞快乐 ","date":"2020-06-05","objectID":"/vim-0/:10:1","tags":["Vim"],"title":"🔧第 N 次的 Vim 入门记录","uri":"/vim-0/"},{"categories":["折腾指南"],"content":"上一个计划“每日学习 vim 计划”在今天晚上（圣诞节）结束了，感觉效果挺好；虽然只存活了 10 天；但是 vim 是曾经接触过，所以计划就提前结束了； 这次开始学习MySQL; 为下学期数据库选修课做准备 Begin at Christmas ","date":"2018-12-25","objectID":"/sql-begin/:0:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"登录到 mysql mysql -h 主机名 -u 用户名 -p 和 shell 一样，输入 exit 退出登录 ","date":"2018-12-25","objectID":"/sql-begin/:1:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"创建数据库 对表操作之前需要先选定 database；如果没有 database 可以先新建 create database samp_db character set gbk; drop database samp_db; #删除库 use samp_db #选择数据库 show databases[tables] #显示数据库列表或者表列表 ","date":"2018-12-25","objectID":"/sql-begin/:2:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"数据类型 在创建 table 前先了解下数据类型 数字类型 MySQL 数据类型 含义（有符号） tinyint(m) 1 个字节 范围 (-128~127) smallint(m) 2 个字节 范围 (-32768~32767) mediumint(m) 3 个字节 范围 (-8388608~8388607) int(m) 4 个字节 范围 (-2147483648~2147483647) bigint(m) 8 个字节 范围 (+-9.22*10 的 18 次方） 属性 存储空间 精度 精确性 说明 FLOAT(M, D) 4 bytes 单精度 非精确 单精度浮点型，m 总个数，d 小数位 DOUBLE(M, D) 8 bytes 双精度 比 Float 精度高 双精度浮点型，m 总个数，d 小数位 时间类型 类型 字节 例 精确性 DATE 三字节 2015-05-01 精确到年月日 TIME 三字节 11:12:00 精确到时分秒 DATETIME 八字节 2015-05-01 11::12:00 精确到年月日时分秒 TIMESTAMP 2015-05-01 11::12:00 精确到年月日时分秒 TIMESTAMP 类型可动态变化 字符串类型 类型 单位 最大 特性 CHAR 字符 最大为 255 字符 存储定长，容易造成空间的浪费 VARCHAR 字符 可以超过 255 个字符 存储变长，节省存储空间 TEXT 字节 总大小为 65535 字节，约为 64KB - Day Two 今天终于又空闲下来继续学习 MySQL 了； 不能一口气吃成胖子； 有一个比较基础的问题就是每次使用 sql 时 都要启动 MariaDB 的系统守护进程systemctl start mariadb.service当然你可以设置成开机自启；如果你不在意那点开机速度的话 ","date":"2018-12-25","objectID":"/sql-begin/:3:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"Primary Key 主键 数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据表只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 主键是唯一且不重复的；比如在学校里学号是不会重复的，就可以设置为主键。 ","date":"2018-12-25","objectID":"/sql-begin/:4:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"创建 Table 下面这段代码是创建 Table 的常见形式。 -- 如果数据库中存在 user_accounts 表，就把它从数据库中 drop 掉 DROP TABLE IF EXISTS `user_accounts`; CREATE TABLE `user_accounts` ( `id` int(100) unsigned NOT NULL AUTO_INCREMENT primary key, `password` varchar(32) NOT NULL DEFAULT '' COMMENT '用户密码', `reset_password` tinyint(32) NOT NULL DEFAULT 0 COMMENT '用户类型：0－不需要重置密码；1- 需要重置密码', `mobile` varchar(20) NOT NULL DEFAULT '' COMMENT '手机', `create_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `update_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), -- 创建唯一索引，不允许重复 UNIQUE INDEX idx_user_mobile(`mobile`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表信息'; NOT NULL代表数据列不允许包含NULL;NULL代表可以为NULL 元旦特辑 第三篇就到元旦特辑了，嘻嘻嘻，在大家都在写电生理报告的时候，我想到自己已经鸽了很久的 MySQL 篇了 好了，学习数据库肯定得有数据啊，自己创建一个固然要学，可是自己编一个数据库出来也不现实啊 ","date":"2018-12-25","objectID":"/sql-begin/:5:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"导入.sql 文件 MySQL 数据文件的后缀是.sql 官方有提供几个 example databases; 所以直接用官方给的吧 MySQL example databases 我下载的是sakila，下载下来后unzip后得到三个文件sakila-schema.sql,sakila.mwb,sakila-data.sql 在 mariadb 中 使用 source 命令导入下载的 database,source [path]; 顺序是先导入 sakila-schema.sql, 然后是 sakila-data mariadb root@localhost:sakila\u003e show databases +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sakila | +--------------------+ 4 rows in set Time: 0.034s 可以看到 sakila 已经被导入进来了； mariadb root@localhost:sakila\u003e use sakila You are now connected to database \"sakila\" as user \"root\" Time: 0.001s mariadb root@localhost:sakila\u003e show tables 10 rows in set Time: 0.033s +------------------+ | Tables_in_sakila | +------------------+ | actor | | address | | category | | city | | country | | customer | | film | | film_actor | | film_category | | film_text | +------------------+ XD; 导入成功了；可以开始继续学习操作了 ","date":"2018-12-25","objectID":"/sql-begin/:6:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"SELECT 查询 如果看到 select 后面跟了很长一串；请不要惊慌，select 最核心的语法只是 SELECT 列名称 1, 列名称 2 FROM 表名称 首先要注意两个列名称之间用逗号分隔，不然会被认为是取一个别名（省略 as） 其次如果要选取所有列 可以使用 SELECT * FROM 表名称 如果有两张表，有相同的字段名，比如两个表 t1 和 t2，那么查询时需要显式指定查询的字段属于哪张表，select t1.id, t1.name, t2.id, t2.name from t1, t2，以避免冲突 如果想查询不重复的值只要使用DISTINCT就可以了 SELECT DISTINCT 列名称 FROM 表名称 Day Four ","date":"2018-12-25","objectID":"/sql-begin/:7:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"WHERE where 语句用来设定条件，可以和 SELECT 组合，也可以和DELETE，INSERT等组合 判断条件的操作符有=、！=、\u003e、\u003c、\u003e=、\u003c= 两个或者两个以上条件，可以用OR、AND连接 SELECT * FROM Persons WHERE FirstName=‘Thomas’ AND LastName=‘Carter’; ","date":"2018-12-25","objectID":"/sql-begin/:8:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"UPDATE UPDATE用于更新表中的数据 UPDATE 表名称 SET 列名称 = 新值，列名称 = 新值 WHERE 列名称 = 某值 update actor set last_name = 'Han', first_name = 'Taohai' where actor_id = 1; +----------+------------+-----------+---------------------+ | actor_id | first_name | last_name | last_update | +----------+------------+-----------+---------------------+ | 1 | Taohai | Han | 2019-01-02 12:09:26 | +----------+------------+-----------+---------------------+ Day Five ","date":"2018-12-25","objectID":"/sql-begin/:9:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"INSERT INTO INSERT INTO用于向表中插入新行 INSERT INTO 表名称 VALUES （值 1, 值 2,….) 如果要指定要插入数据的列可以使用 INSERT INTO table_name （列 1, 列 2,…) VALUES （值 1, 值 2,….) 比如 insert into actor (first_name, last_name) values ('Yi', 'Han') 将插入一新行，actor_id 是ACTO_INCREMENT的，所以不用指定，也会自动生成 ","date":"2018-12-25","objectID":"/sql-begin/:10:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"DELETE DELETE用于删除表中一行 DELETE FROM 表名称 WHERE 列名称 = 值 在不用WHERE约束的情况下，将删除表中所有行，DELETE FROM table_name Day Six ","date":"2018-12-25","objectID":"/sql-begin/:11:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"ORDER BY 在select语法的最后加上ORDER BY 列名称就可以对所选的数据进行排序，缺省是升序排列 如果要降序，可以在最后加上DESC的描述 SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC ","date":"2018-12-25","objectID":"/sql-begin/:12:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"IN 在WHERE语法中可以使用IN来规定多个值 语法为 SELECT 列名称 FROM Table 名称 WHERE 列名称 IN (值1， 值2，…) 使用NOT可以排除某些值，语法为在IN之前加NOT， SELECT 列名称 FROM Table 名称 WHERE 列名称 NOT IN (值1， 值2，…) ","date":"2018-12-25","objectID":"/sql-begin/:13:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"UNION UNION用于 合并两个SELECT里，合并是指 第二个查询直接接在第一个查询后面 考试周到了，这大概是本学期最后一更了，鸽了鸽了 ","date":"2018-12-25","objectID":"/sql-begin/:14:0","tags":["MySQL"],"title":"每日学习 MySQL 计划","uri":"/sql-begin/"},{"categories":["折腾指南"],"content":"我的 Vim 配置文件放置在我的 Github 上，如有兴趣可以查阅 在尝试了很多集成性很高的 Vim 配置（比如 SpaceVim 和 rafi 大神的配置）之后，我决定重新使用和打磨自己的配置。原因是因为这些集成性很高的配置有太多我不需要的东西，或者是太多我不知道如何使用的东西，造成启动速度比较慢。当我需要某项功能，我自己去寻找解决的方法，也能让我迅速熟悉。 又因为 Vim 本身就有很多快捷键，添加了诸多插件后，又增加了成吨的快捷键，所以我决定写一个笔记。 ","date":"2018-12-17","objectID":"/vimrcnote/:0:0","tags":["Vim"],"title":"我的 Vimrc 快捷键备忘","uri":"/vimrcnote/"},{"categories":["折腾指南"],"content":"Vim 本身加强 Vim 本身加强指的是一些 vim 没有的功能通过插件或者设置实现的。 \u003cleader\u003ew 保存修改；:W 使用sudo保存文件 \u003cleader\u003eq 新建一个 buffer J norm 模式下快速向下 20 行 K norm 模式下快速向上 20 行 H 键用于定位到当前行第一个非空白字符， L 键定位到当前行最后一个字符 \u003cleader\u003ecd 将当前目录切换至 buffer 所在目录 增强 f 键 normal 模式下，再次按f可以将光标移到下一个 find 的字母 search 后改变了 n 和 N 的方向，让 n 永远向前，N 永远向后 \u003cleader\u003eaf 用于 autoformat [e 将当前行上移，]e 将当前行下移 [\u003cspace\u003e 在当前行之上添加空白行，]\u003cspace\u003e 在当前行之下添加空白行 [b和 ]b 左右切换 buffer ","date":"2018-12-17","objectID":"/vimrcnote/:1:0","tags":["Vim"],"title":"我的 Vimrc 快捷键备忘","uri":"/vimrcnote/"},{"categories":["折腾指南"],"content":"跳转窗口 跳转窗口部分和tmux共享快捷键。下面的M指的是Alt键 \u003cM-C-j\u003e \u003cM-C-k\u003e \u003cM-C-h\u003e \u003cM-C-l\u003e 在窗口之间上下左右切换 \u003cM-C-n\u003e 跳转到上一个窗口 ","date":"2018-12-17","objectID":"/vimrcnote/:2:0","tags":["Vim"],"title":"我的 Vimrc 快捷键备忘","uri":"/vimrcnote/"},{"categories":["折腾指南"],"content":"Coc 快捷键 Coc指的是 neoclide/coc.nvim 是新一代的补全框架，同时包括了很多额外的功能。它也可以安装 extension，也会产生很多的快捷键。 Tab 键补全列表往下 Shift+Tab补全列表往上 Enter 选中 Snippet 后 确认补全 \u003cspace\u003ea 打开当前文件错误的列表 [g ]g 错误直接跳转 \u003cspace\u003ef 打开文件模糊搜索列表 \u003cspace\u003ee 打开 extension 列表 \u003cspace\u003ew 查找光标下的单词 \u003cspace\u003em 打开最近文件列表 \u003cspace\u003ep 打开最近的一个列表 Esc退出列表 U 查看光标下的单词的文档 gd跳转到定义 ","date":"2018-12-17","objectID":"/vimrcnote/:3:0","tags":["Vim"],"title":"我的 Vimrc 快捷键备忘","uri":"/vimrcnote/"},{"categories":["折腾指南"],"content":"Defx 目录树快捷键 使用 Defx 作为目录树插件。 \u003cleader\u003ee 打开和关闭目录树。下面的快捷键都是在 defx 下的 Enter键或者o键 打开文件，如果在目录上摁，那就是展开目录 x 关闭目录 l和h 打开和关闭目录 yy 复制目录或者文件地址 c 复制文件 p 粘贴文件 . 显示隐藏文件 ","date":"2018-12-17","objectID":"/vimrcnote/:4:0","tags":["Vim"],"title":"我的 Vimrc 快捷键备忘","uri":"/vimrcnote/"},{"categories":["折腾指南"],"content":"使用终端是一件很爽的事情，啪啪啪敲完一行命令然后 Hit Enter 自然是 Linux User 的最爱。 但有时候不是忘了加sudo就是又把-摁成了0. 这时候狂摁方向键就显得不睿智了，其实 zsh 自带了一些好用的快捷键。 使用 bindkey 命令可以查看当前的快键键绑定 $ bindkey 其中常用的快捷键有： C + u：清空当前输入的命令 C + a：移动到命令首 C + e：移动到命令尾 C + f：向左移动 C + b：向右移动 C + p：上一条命令 C + n：下一条命令 C + r：搜索历史命令 C + h：删除光标之前的字符 C + d：删除光标所指的字符 C + w：删除光标之前的单词 C + k：删除从光标到行尾的内容 !abc ：重复上一个以 abc 开始的命令，不执行 !! ：重复上一个命令，不执行 ","date":"2018-05-20","objectID":"/shell-2/:0:0","tags":["Shell"],"title":"节省手指关节耐久 -- Zsh 快捷键","uri":"/shell-2/"},{"categories":["学习笔记"],"content":"为什么要写切片呢，因为当时看书学切片的时候，感觉这东西和 MATLAB 和 numpy 里面很像，就粗略的看了一下但没有仔细的深究，但每次用的时候都觉得需要查一下怎么用，尤其是 [:] 和 [: :]，总是傻傻的分不清楚。 估计是太笨了。所以写篇笔记吧。… 首先我们知道 list[num] 可以直接索引列表，这个没什么可说的。 \u003e\u003e\u003e colors=[\"red\",\"blue\",\"green\"] \u003e\u003e\u003e colors[0] 'red' #返回元素 然后就是 [:] 的切片方式了，就是 list[start_index:end_index]，这个时候就有点意思了。 要记住 [:] 和 [: :] 返回的都是列表，即使你只切了一个元素出来。 另外，end_index 取得是开集，也就是用数学语言描述其实取的是 [start_index,end_index)，不清楚为什么要这么设计，这样设计也有好处 [0:7] 就可以直接表示取前七个元素，也可以简写成 [:7]，同样 range(5) 就可以直接表示 5 个元素的迭代器了。 \u003e\u003e\u003e b[:3] [0, 1, 2] \u003e\u003e\u003e b[3:5] [3, 4] 讲 [: :] 之前先看一个例子 \u003e\u003e\u003e s = 'abcdefg' \u003e\u003e\u003e print(s[::-1]) gfedcba s[: : -1] 相当于翻转列表了，s[: : 1] 就相当于不变了。所以负数表示从尾开始切，正数表示从头开始切。 +1，-1，就是表示步进了，步进为 2 就是跳一个去一个，步进为 3 就是跳 2 个取一个。 \u003e\u003e\u003e print(s[::1]) abcdefg \u003e\u003e\u003e print(s[::2]) aceg \u003e\u003e\u003e print(s[::3]) adg \u003e\u003e\u003e print(s[::4]) ae \u003e\u003e\u003e print(s[::-2]) geca 以上，不仅仅是列表如此。 ","date":"2017-12-25","objectID":"/learning-python-6/:0:0","tags":["Python","Numpy"],"title":"🐍Numpy 中神奇的切片","uri":"/learning-python-6/"},{"categories":["学习笔记"],"content":"动态编程语言是高级程序设计语言的一个类别，在计算机科学领域已被广泛应用。它是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。ECMAScript（JavaScript）便是一个动态语言，除此之外如 PHP、Ruby、Python 等也都属于动态语言，而 C、C++ 等语言则不属于动态语言。 当定义了一个 class 的实例之后，我们能动态的绑定任何属性和方法。涨知识了。.. class Student(object): pass han = Student() han.name = 'han' #绑定 name 属性 print(han.name) 给实例绑定方法需要用到 MethodType from types import MethodType def set_age(self, age): self.age = age class Student(object): pass s_one = Student() s_one.set_age = MethodType(set_age,s_one) 但是，以上两种都是给 class 的某一实例单独绑定，对 class 的另外实例是不起作用的。 当然我们可以直接给 class 绑定。 def set_name(self,name) self.name = name Student.set_name = set_name ","date":"2017-12-16","objectID":"/learning-python-5/:0:0","tags":["Python"],"title":"🐍python 的动态语言特性","uri":"/learning-python-5/"},{"categories":["学习笔记"],"content":"使用、__slots__限制实例的属性 使用、__slots__能够限制添加到实例的属性。 class Student(object): __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称 但是__slots__只对当前类起作用，对它的子类不起作用。除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 那要是父类没有__slots__呢？那就不生效。指的是就算子类指定了__slots__也不会生效 class Person(object): pass class Student(Person): __slots__ = ('name', 'age') # 用 tuple 定义允许绑定的属性名称 s = Student() s.name = \"tom\" s.age = 23 s.gg = 99 print(s.name, s.age, s.gg) 则不会报错。继承链中如果哪一级少了__slots__属性实现，子类中的__slots__失效。 ","date":"2017-12-16","objectID":"/learning-python-5/:1:0","tags":["Python"],"title":"🐍python 的动态语言特性","uri":"/learning-python-5/"},{"categories":["学习笔记"],"content":"@property 的使用 Python 内置的 @property 装饰器能把一个方法变成属性调用 class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value \u003c 0 or value \u003e 100: raise ValueError('score must between 0 ~ 100!') self._score = value 如果不定义 setter 属性，只定义 getter 属性，那么它就是一个只读的属性。 ","date":"2017-12-16","objectID":"/learning-python-5/:2:0","tags":["Python"],"title":"🐍python 的动态语言特性","uri":"/learning-python-5/"},{"categories":["学习笔记"],"content":"装饰器 (Decorator) 就是为了增强某个函数的功能，但又不想改变这个函数本来的定义而引进的。 ‘@’ 用做函数的修饰符，可以在模块或者类的定义层内对函数进行修饰，出现在函数定义的前一行，不允许和函数定义在同一行。 def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper @log #注意这里没有 () def now(): print('2015-3-25') \u003e\u003e\u003e now() call now(): 2015-3-25 把 @log 放到 now() 函数的定义处，相当于执行了语句： now = log(now) 这样，当其他函数也需要这个装饰的时候，也在函数前加 @… 就可以避免大量重复的代码。 ","date":"2017-12-11","objectID":"/learning-python-4/:0:0","tags":["Python"],"title":"🐍python 中的装饰器","uri":"/learning-python-4/"},{"categories":["学习笔记"],"content":"带参数的装饰器 带参数的装饰器其实是对原装饰器的封装。 def use_logging(level): def decorator(func): def wrapper(*args, **kwargs): if level == \"warn\": logging.warn(\"%sis running\" % func.__name__) return func(*args) return wrapper return decorator @use_logging(level=\"warn\") def foo(name='foo'): print(\"i am %s\" % name) foo() 相当于执行了： foo=using_logging(level=“warm”)(foo) 使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了。 Python 内置的 functools.wraps 就是解决这个问题的。 import functools def log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s%s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator ","date":"2017-12-11","objectID":"/learning-python-4/:0:1","tags":["Python"],"title":"🐍python 中的装饰器","uri":"/learning-python-4/"},{"categories":["学习笔记"],"content":"当你不确定你的函数里将要传递多少参数时你可以用*args, 它可以传递任意数量的参数。 **kwargs允许你使用没有事先定义的参数名。 *arg 会把多出来的位置参数转化为 tuple **kwarg 会把关键字参数转化为 dict *args和**kwargs可以同时在函数的定义中，但是*args必须在**kwargs前面。 \u003e\u003e\u003e def print_everything(*args): for count, thing in enumerate(args): ... print ('{0}. {1}'.format(count, thing)) ... \u003e\u003e\u003e print_everything('apple', 'banana', 'cabbage') 0. apple 1. banana 2. cabbage \u003e\u003e\u003e def table_things(**kwargs): ... for name, value in kwargs.items(): ... print ('{0} = {1}'.format(name, value)) ... \u003e\u003e\u003e table_things(apple = 'fruit', cabbage = 'vegetable') cabbage = vegetable apple = fruit 当调用函数时你也可以用、和、*语法。例如： \u003e\u003e\u003e def print_three_things(a, b, c): ... print 'a = {0}, b = {1}, c = {2}'.format(a,b,c) ... \u003e\u003e\u003e mylist = ['aardvark', 'baboon', 'cat'] \u003e\u003e\u003e print_three_things(*mylist) a = aardvark, b = baboon, c = cat 两个混在一起用要注意顺序 def learnarg(*args, **kwargs): for i in args + tuple(kwargs.values()): print(i) for key, value in kwargs.items(): print('{}={}'.format(key, value)) learnarg('Wo', 4, 'KissAndRun', b=7, a=5, c='Hi') ","date":"2017-12-07","objectID":"/learning-python-3/:0:0","tags":["Python"],"title":"🐍'*arg 和** kwarg'","uri":"/learning-python-3/"},{"categories":["学习笔记"],"content":"map() map(func,Iterable) map() 函数接收两个参数，一个是函数，一个是 Iterable. map 将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回。 \u003e\u003e\u003e def f(x): ... return x * x ... \u003e\u003e\u003e r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) \u003e\u003e\u003e list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81] r 是一个 Iterator，是一种惰性序列。所以要用 list() 将其转变为 list 输出。 何为惰性？ 迭代器仅仅在迭代至某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。 ","date":"2017-12-04","objectID":"/learning-python-2/:1:0","tags":["Python"],"title":"🐍一些 python 的内置函数","uri":"/learning-python-2/"},{"categories":["学习笔记"],"content":"reduce() reduce()把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) \u003e\u003e\u003e from functools import reduce \u003e\u003e\u003e def fn(x, y): ... return x * 10 + y ... \u003e\u003e\u003e def char2num(s): ... return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s] ... \u003e\u003e\u003e reduce(fn, map(char2num, '13579')) 13579 ","date":"2017-12-04","objectID":"/learning-python-2/:2:0","tags":["Python"],"title":"🐍一些 python 的内置函数","uri":"/learning-python-2/"},{"categories":["学习笔记"],"content":"lambda lambda 的一般形式是关键字 lambda 后面跟一个或多个参数，紧跟一个冒号，以后是一个表达式。 f = lambda x,y,z : x+y+z print f(1,2,3) #6 g = lambda x,y=2,z=3 : x+y+z print g(1,z=4,y=5) #10 ","date":"2017-12-04","objectID":"/learning-python-2/:3:0","tags":["Python"],"title":"🐍一些 python 的内置函数","uri":"/learning-python-2/"},{"categories":["学习笔记"],"content":"参数的传递 对象有两种，“可更改”（mutable）与“不可更改”（immutable）对象。 在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list, dict, set 等则是可以修改的对象。 不可变的对象作为参数时，函数不能使其改变。 a = 1 def fun(a): #创建一个新的引用指向 1 a = 2 #这里将引用指向了一个不可变对象 2 fun(a) print a # 1 理解 1 是一个 number 对象，a 是对象的引用（变量）。 a = [] def fun(a): a.append(1) #对象可更改，直接在内存修改 fun(a) print a # [1] ","date":"2017-12-02","objectID":"/learning-python-1/:1:0","tags":["Python"],"title":"🐍一些 python 的基础知识","uri":"/learning-python-1/"},{"categories":["学习笔记"],"content":"@classmethod 和 @staticmethod Python 其实有 3 个方法，即静态方法 (staticmethod), 类方法 (classmethod) 和实例方法，如下： def foo(x): print \"executing foo(%s)\"%(x) class A(object): def foo(self,x): print \"executing foo(%s,%s)\"%(self,x) @classmethod def class_foo(cls,x): print \"executing class_foo(%s,%s)\"%(cls,x) @staticmethod def static_foo(x): print \"executing static_foo(%s)\"%x a=A() 这里先理解下函数参数里面的 self 和 cls. 这个 self 和 cls 是对类或者实例的绑定，对于一般的函数来说我们可以这么调用foo(x), 这个函数就是最常用的，它的工作跟任何东西（类，实例）无关。对于实例方法，我们知道在类里每次定义方法的时候都需要绑定这个实例，就是foo(self, x), 为什么要这么做呢？因为实例方法的调用离不开实例，我们需要把实例自己传给函数，调用的时候是这样的a.foo(x)（其实是foo(a, x)). 类方法一样，只不过它传递的是类而不是实例，A.class_foo(x). 注意这里的 self 和 cls 可以替换别的参数，但是 python 的约定是这俩，还是不要改的好。 对于静态方法其实和普通的方法一样，不需要对谁进行绑定，唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用。 \\ 实例方法 类方法 静态方法 a = A() a.foo(x) a.class_foo(x) a.static_foo(x) A 不可用 A.class_foo(x) A.static_foo(x) ","date":"2017-12-02","objectID":"/learning-python-1/:2:0","tags":["Python"],"title":"🐍一些 python 的基础知识","uri":"/learning-python-1/"},{"categories":["学习笔记"],"content":"类变量 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。 class people(object): name = 'jack' p1 = people() p2 = people() p1.name = 'tom' #p1.name 指向了'tom' print(p1.name) #输出 tom print(p2.name #输出 jack people.name = 'marry' print(p2.name,p1.name) #输出 marry tom class people(object): name = ['jack'] p1 = people() p2 = people() p1.name.append('tom') #改变的是内存的内容而不是地址 print(p1.name) #输出 ['jack','tom'] print(p2.name) #同上 people.name.append('marry') #输出 ['jack','tom','marry'] print(p2.name,p1.name) ","date":"2017-12-02","objectID":"/learning-python-1/:3:0","tags":["Python"],"title":"🐍一些 python 的基础知识","uri":"/learning-python-1/"},{"categories":["学习笔记"],"content":"python 的自省 hasattr(object, name) 判断 object 是否有 name 这个方法。name 应该是个字符串。 getattr(object, name[,default]) 获得 object 中为 name 的属性或者方法。不存在则打印 default。获取属性则直接打印，获取方法则打印地址（加括号可运行）。 setattr(object, name, values) 给对象的属性赋值，若属性不存在，先创建再赋值。 isinstance（object，type） 来判断一个 object 是否是一个已知的类型。 ","date":"2017-12-02","objectID":"/learning-python-1/:4:0","tags":["Python"],"title":"🐍一些 python 的基础知识","uri":"/learning-python-1/"},{"categories":["学习笔记"],"content":"列表推导式 [Expression for Variable in list if (...)] 举例： \u003e\u003e\u003e a = [1,2,3,4,5,6,7,8,9,10] \u003e\u003e\u003e [x for x in a if x % 2 == 0] [2, 4, 6, 8, 10] ","date":"2017-12-02","objectID":"/learning-python-1/:5:0","tags":["Python"],"title":"🐍一些 python 的基础知识","uri":"/learning-python-1/"},{"categories":["学习笔记"],"content":"多重列表推导 a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] b = [j for i in a for j in i] print(b) #[1, 2, 3, 4, 5, 6, 7, 8, 9] 把 [] 换为 () 可产生生成器（generator），换为{}可产生集合。 ","date":"2017-12-02","objectID":"/learning-python-1/:5:1","tags":["Python"],"title":"🐍一些 python 的基础知识","uri":"/learning-python-1/"},{"categories":["学习笔记"],"content":"字典推导式 d = {key: value for (key, value) in iterable} 举例： mcase = {'a': 10, 'b': 34} mcase_frequency = {v: k for k, v in mcase.items()} print mcase_frequency # Output: {10: 'a', 34: 'b'} ","date":"2017-12-02","objectID":"/learning-python-1/:6:0","tags":["Python"],"title":"🐍一些 python 的基础知识","uri":"/learning-python-1/"},{"categories":["折腾指南"],"content":"在 Ubuntu 上安装 git 打开命令行界面，输入： sudo apt-get install git 没有提示错误则安装成功。 ","date":"2017-10-28","objectID":"/git-0/:1:0","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"配置 git 信息 还是在命令行界面，输入 git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" 能和 github 账号一样就尽量一样吧。 j# 配置 ssh 公钥 如果不设置 ssh 公钥，则每次的 git push 都要输入 github 的账号密码，非常的麻烦。 ","date":"2017-10-28","objectID":"/git-0/:2:0","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"第一步 查看 home 目录下是否有。ssh 目录，一般情况是没有的，需要我们敲命令生成这个目录，在终端输入 ssh-keygen -t rsa -C “youremail@example.com” 邮箱就是刚刚第二步设置的。然后一路按回车，其实就是不设置密码。然后你就会看到 home 目录下多了。ssh 目录。 ","date":"2017-10-28","objectID":"/git-0/:2:1","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"第二步 进入。ssh 目录你会看到两个文件* id_rsa *和* id_rsa.pub*,*id_rsa *是私钥，*id_rsa.pub *自然就是公钥啦。然后我们需要做的就是把* id_rsa.pub *文件中的内容拷贝一下。 ","date":"2017-10-28","objectID":"/git-0/:2:2","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"第三步 进入你自己的 github，进入* Settings-\u003eSSH and GPG keys-\u003eNew SSH key*, 然后在 Key 那栏下面将第四步拷贝的东西粘贴进去就可以了，最后点击 Add SSH key 按钮添加。 这样以后使用 git 命令时，第一次会有警告，输入 yes 之后，以后就可以直接 pull 或者 push 啦。 ","date":"2017-10-28","objectID":"/git-0/:2:3","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"使用 Git 命令 git 命令非常多。 常用的有这样几个，基本可以满足日常的要求。 ","date":"2017-10-28","objectID":"/git-0/:3:0","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"git clone 复制 github 上下载的链接 git clone git@github.com:cyrushan/cyrushan.github.io.git 即可以将 github 上的文件下载到当前的目录。但注意要复制 ssh 链接。 ","date":"2017-10-28","objectID":"/git-0/:3:1","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"提交 git add [file] # 将工作文件修改提交到本地暂存区 git commit -m “备注“ git push 以上三条命令，一般经常一起使用提交修改。注意，此时的命令行目录应该在你 git clone 的目录下。 ","date":"2017-10-28","objectID":"/git-0/:3:2","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"},{"categories":["折腾指南"],"content":"我的 Git 学习笔记 git log --pretty=oneline 查看 log 并整洁的输出，查看 commit id git reset --hard HEAD^ 回退到上一个版本 上上个版本为 HEAD^^ git reset --hard commit id 可以会退到 id 所对应的版本 git reflog 查看命令的历史，确定回到未来的哪个版本 尽量不要使用 git pull 而用 git fetch 和 git merge 代替 git checkout --file 可以丢弃工作区的修改，若已经提交到 stage，则回到提交前，若没有则回到版本库的状态 git checkout branchName 回到 branchName 分支：D git diff 工作区和暂存区的比较 git diff --cached 暂存区和分支的比较 git branch 列出分支 git branch branchName 新建分支 git branch -d branchName 删除分支 git merge branchName 合并分支到 master git stash 储藏当前工作现场 git stash list 查看储藏的列表 git stash apply stash@{0} 恢复所储藏的 git tag tagName 给最近一次 commit 打上 tag git tag tagName commitID 给 commitID 的提交打上 tag git show tagName 查看标签信息 git tag -d tagName 本地删除 tag git push origin :refs/tags/tagName 远程删除 tag git push origin --delete \u003cbranchName\u003e 删除远程分支 git push origin \u003cbranchName\u003e 创建远程分支 git rm -r --cached . .gitignore 只能忽略那些原来没有被追踪的文件，解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交。 ","date":"2017-10-28","objectID":"/git-0/:4:0","tags":["Git"],"title":"Git 配置和常用命令","uri":"/git-0/"}]